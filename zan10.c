#include <stdio.h>
#include <stdlib.h>

struct person
{
    char* name;
    int age;
};

void createPtr()
{
    int *p = malloc(sizeof(int));
    if (!p) return;
    *p = 2;
    printf("%d \n", (*p));
    free(p);
}

int* createPtr2()
{
    static int *p = NULL;
    if(p == NULL)
    {
        p = malloc(sizeof(int));
        *p = 2;
    }
    printf("%d \n", (*p));
    (*p)++;
    return p;
}

int *ptr6 = NULL;

void createPtr3()
{
    printf("%d \n", (*ptr6));
    (*ptr6)++;
}


int *addArrays(int a[], int b[], int n)
{
    int *ptr = calloc(n, sizeof(int));
    for (int i = 0; i < n; i++){
        ptr[i] = a[i] + b[i];
    }
    return ptr;
}

int main(void){
    /*
    Для управления динамическим выделением памяти используется ряд функций, которые определены в заголовочном файле stdlib.h

    malloc(), прототип:

    void *malloc(unsigned s);
    Выделяет память длиной в s байт и возвращает указатель на начало выделенной памяти. В случае неудачного выполнения возвращается NULL

    calloc(), прототип:
    
    void *calloc(unsigned n, unsigned m);
    Выделяет память для n элементов по m байт каждый и возвращает указатель на начало выделенной памяти. В случае неудачного выполнения возвращает
    NULL

    free(), прототип:
    void *free(void *b);
    Освобождает ранее выделенный блок памяти, на начало котрого указывает указатель b

    realloc(), прототип:
    void *realloc(void* b, unsigned k);
    изменяет размер ранее выделенного блока памяти, на начало которого указывает указатель b, до размера k байт. Если указатель b = NULL, то
    действие аналогично malloc
    */

    int *ptr = malloc(sizeof(int)); //выделить память для одного int, не забыть преобразовать к типу указателя в VStudio
    *ptr = 16;

    //int *ptr = malloc(sizeof *ptr);
    printf("%d \n", *ptr);
    free(ptr);
    /*
    int *ptr = malloc(sizeof(int));
    if (ptr != NULL)
    {
        *ptr = 16;
        printf("%d \n", *ptr);
    }
    free(ptr);

    Несмотря на осовобождение при помощи free() указатель сохраняет свой адрес, и теоретически мы можем обращаться к памяти по данному указателю.
    free(ptr);
    ptr = NULL;
    */
   int n = 5;
   int *ptr1 = malloc(n * sizeof(int));
   if (ptr1)
   {
    ptr1[0] = 1;
    ptr1[1] = 2;
    ptr1[2] = 3;
    ptr1[3] = 4;
    ptr1[4] = 5;
    for (size_t i = 0; i < n; i++)
    {
        printf("%d \n", ptr1[i]);
    }
   }
   free(ptr1);
   ptr1 = NULL;


   struct person *ptr2 = malloc(sizeof(struct person));
   if (ptr2)
   {
    ptr2->name = "Tom";
    ptr2->age = 18;
    printf("%s : %d \n", ptr2->name, ptr2->age);
   }
   free(ptr2);
   ptr2 = NULL;

   int *ptr3 = calloc(1, sizeof(int));
   if (ptr3)
   {
    //по умлочанию значение 0
    printf("Initial value: %d \n", *ptr3);
    *ptr3 = 18;
    printf("New value: %d \n", *ptr3);
   }
   free(ptr3);
   ptr3 = NULL;

   int size = sizeof(int);
   int *ptr4 = malloc(size);

   if (ptr4)
   {
    printf("Address: %p, size: %d \n", (void*)ptr4, size);
   }

   size = 4 * sizeof(int);
   int *ptr4_new = realloc(ptr4, size);
   if (ptr4_new)
   {
    printf("Address: %p, size: %d \n", (void*)ptr4, size);
    free(ptr4_new);
    ptr4_new = NULL;
   }
   else
   {
    free(ptr4);
    ptr4 = NULL;
   }
/*
   //Выделение памяти для двумерного массива произвольной длины
   int k; //вводимое число
   int r_count; //количество строк
   int *rows; //указатель для блока памяти для хранения по строкам
   int **table; //указатель для блока памяти для массива указателей

   //ввод количества строк
   printf("Rows count = ");
   scanf("%d", &r_count);

   //выделение памяти для двумерного массива
   table = calloc(r_count, sizeof(int *));
   rows = malloc(sizeof(int) *r_count);

   //циклом проходимся по строкам и задаем количество столбцов в каждой строке, а затем вводим элементы строк
   for (int i = 0; i < r_count; i++){
    printf("Count columns for row %d= ", i);
    scanf("%d", &rows[i]);
    table[i] = calloc(rows[i], sizeof(int));

    for (int j = 0; j < rows[i]; j++){
        printf("table[%d][%d]=",i, j);
        scanf("%d", &k);
        table[i][j] = k;
    }
   }

   //вывод введенных чисел в консоль
   printf("\n");
    for (int i = 0; i < r_count; i++){
        printf("\n");
        for (int j = 0; j < rows[i]; j++){
            printf("%d \t", table[i][j]);
        }
        //освобождение памяти для той строки, элементы которой уже вывели
        free(table[i]);
   }

   //освобождение памяти от иных указателей
   free(table);
   free(rows);


   /*
   В зависимости от области видимости указателя может быть три варианта:

   1) Указатель определен в блоке кода:
   В этом случае указатель будет доступен только в пределах данного блока кода. Соответственно памяти необходимо освобождать при выходе из
   этого блока кода

   2) Указатель определен на статический объект. В этом случае динамическая памяти выделяется один раз и доступна через указатель при каждом
   повторном входе в блок. В этом случае память нужно освобождать только после завершения ее использования

   3) Указатель является глобальным объектом по отношению к блоку. В этом случае динамическая память доступна во всех блоках, где доступен указатель,
   а памяти нужно освобождать только после завершения ее использования.
   */
   createPtr();
   createPtr();
   createPtr();
   int *ptr5;
   ptr5 = createPtr2();
   ptr5 = createPtr2();
   ptr5 = createPtr2();
   free(ptr5);

   ptr6 = malloc(sizeof(int));
   *ptr6 = 2;

   createPtr3();
   createPtr3();
   createPtr3();

   free(ptr6);

   //Указатель как результат функции
   /*
   тип *имя_функции (параметры)
   {
    ...тело функции
    тип *имя_указателя
    return имя_указателя
   }
   */
  int a[] = {2, 3, 4, 2, 3};
  int b[] = {1, 2, 3, 4, 5};

  int n1 = sizeof(a)/sizeof(int);

  int *ptr7 = addArrays(a, b, n1);
  for (int i = 0; i < n; i++){
    printf("%d \t", ptr7[i]);
  }
  free(ptr7);

  /*
  Структура памяти программы на языке С имеет четко определенное устройство, которое орагнизует различные типы данных и кода в отдельные сегменты в
  адресном пространстве процесса.

  Рассмотрим сегментацию памяти

  #include <stdio.h>
  int f(int[]);

  int size = 5;

  int main(void){
    int x[3] = {1, 2, 3};
    int result = f(x);
    return 0;
  }

  int f(int l[])
  {
    int a = 0;
    return a;
  }

  Сегмент стека располагается в верхней части структуры памяти и растет вниз при вызовах функции или создании локальных переменных. 

  В данном примере сегмент стека хранит локальный массив x и локальные перменные result, f, a. Стек работает по прицнипу LIFO (last-in-first-out),
  автоматически управляет выделением и свобождением памяти при вызовах и возврате функций. когда выполняется функция main, она создает пространство
  для массива x и переменной result, в то время как f создает собственный фрейм стек, содержащий локальную переменную a.

  Такое автоматическое управленеи памятью делает стек эффективным для временного хранениия данных, но ограничивает время жизни переменных
  их областью видимости.

  Сегмент динамической памяти (heap). Предоставляет возможности динамического распределения памяти. Расположена heap между стеком и нижними сегментами
  памяти, heap растет вверх и позволяет программам запрашивать памяти во время выполнения с помощью функций malloc(), free().

  Сегмент констант и глобальных переменных. Хранит переменные, которые существуют на протяжении всего выполнения программы. Этот сегмент обычно
  содержит инициализарованные глобальные переменные, статические перменные и строковые литералы, которые должны оставаться доступными из нескольких
  функций на протяжении всего времени существования программы.

  Сегмент кода. Располагается в нижней части структуры программы и содержит скомпилированные машинные инструкции для всех функций программы. Этот 
  сегмент доступен только для чтения, чтобы предотвратить случайное изменение программного кода во время выполнения.
  Stack
  main
  1 - x[0]
  2 - x[1]
  3 - x[2]
  ? - result
  f
  0 - a
  стек идет вниз
  ...
  ...
  ...
  ...
  heap куча идет вверх
  heap
  const + global
  5 - size
  ...
  ...
  code
  */

  //Ввод-вывод и работа с файлами
  /*
  Файл в языке С рассматривается как неструктурирвоанная последовательность байтов. Взаимодействие между приложением и файлами производится посредством
  обмена блоков байт фикисрованной длины. При чтении из файла данные помещаются в буфер операционной системы, а затем побайтно передаются приложению.
  При записи в файл данные накапливаются в буфере, а при заполнении буфера записываются на диск в виде единого блока байт. Буферы представляют участки
  памяти, поэтому передача между приложением и буфером происходит довольно быстро в отличие от взаимодействия с физическими устройствами, например, 
  дисплеем. Файл вместе с предоставляемыми средствами буферизации представляет поток
  */
  //Для открытия потока применяется функции потока применяется fopen
  //прототип: FILE * fopen(имя_файла, режим_открытия). Функция возвращает указатель на структуру, которая имеет тип FILE.

  /*
  Режимы открытия:

  'w': текстовый файл открывается для записи. Если файл ранее существовал, то он пересоздается и записывается заново.
  'r': текстовый файл открывается для чтения.
  'a': текстовый файл открывается для добавления в него новых данных. Если файл существовал ранее, то данные просто добавляются
  'w+': текстовый файл создается для записи/повторной записи. Если файл ранее существовал, то при первой записи после открытия он пересоздается
  и записывается заново. А при последюущих записях после открытия данные добавляются в него без перезаписи.
  'r+': текстовый файл открывается для чтения/записи. Запись допустима в любом месте файла, кроме конца файла, от есть недопустимо увеличение размера
  файла
  'a+': текстовый файл открывается или создается (при его отсутствии) для чтения/записи. В отличие от режима w+ файл при открытии не пересоздается
  заново, а в отличии от режима r+ можно записывать данные в конец файла
  'wb': бинарный файл открывается для записи
  'rb': бинарный файл открывается для чтения
  'ab': бинарный файл открыватеся для дозаписи
  'w+b':бинарный файл создается для записи/чтения
  'r+b': бинарный файл открывается для чтения/записи
  'a+b': бинарный файл открывается или создается (при его отсутствии) для чтения/дозаписи
  */

  /*После заверешения работы с файлом его следует закрыть. Для это применяется функция fclose(): int fclose(указатель_на_поток).
  Функция возвращает число: 0 - если успешно выполнилось и EOF в случае ошибки (end of file).
  */
    FILE *fp = fopen("data.txt", "w");

    /*Если файл расположен не в том же самом каталоге, что и соответствующий исполняемый, то к нему можно прописать либо относительный, либо абсолютный
    путь. Например C:\\CS2\\data.txt */

    //Обработка ошибок. В случае возникновения ошибки fopen() возвращает NULL.
    //perror - встроенная функция, которая выводит ошибку в консоль
    if(!fp){
        perror("Error occured while opening data.txt");
        return 1;
    }
    fclose(fp);
    return 0;
}