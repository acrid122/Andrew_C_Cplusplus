#include <iostream>

using namespace std;

int main(){
    int x {};
    x = 2;

    int x1 {}, x2 {}, x3 {};
    x1 = x2 = x3 = 2;
    //операции присваивания: =. имеют правосторонний порядок, поэтому выполняются справа налево
    /*
    +=, -=, *=, /=, %=, <<=, >>=, &=, |=, ^= - простые операции присваивания
    */
    /*
    if (условие)
    {
    
        инструкции;
    
    }
    */
   if (x1 == 5){
    cout << 5 << endl;
   }
   cout << "Что-то вывело" << endl;
   //Если инструкция только одна, то можно не использовать фигурные скобки
   if (x1 == 2)
        cout << 52 << endl;
   if (x1 == 2) cout << 52 << endl;

   /*
   if (условное_выражение)
   {
   
    инструкция_1

   }
    else
    {
    
    инструкция 2
    
    }
   */
    if (x1 == 5)
    {
        cout << 5 << endl;
    }
    else
    {
        cout << 52 << endl;
    }

    if (x1 == 5)
    {
        cout << 5 << endl;
    }
    else if (x1 == 2)
    {
        cout << 2 << endl;
    }
    else
    {
        cout << 52 << endl;
    }
    
    //Можно записать так, так как только 1 инструкция
    if (x1 == 5) cout << 5 << endl;
    else if (x1 == 2) cout << 2 << endl;
    else cout << 52 << endl;

    //Целые числа в условии преобразуются в bool. true - для ненулевых значений и false - для нового

    int x4 {5}, x5 {2};

    if (x4 == 5)
    {
        if (x5 == 2) cout << 2 << endl;
        else cout << 5 << endl;
    }
    else
    {
        cout << "!=5" << endl;
    }
    /*
    if (инициализация; условие)
    {
    }
    */

    if (int c {x4 - x5}; x4 > x5)
    {
        cout << "ура " << c << endl;
    }
    else
    {
        cout << "не ура " << c << endl;
    }

    if (int ost {x4 % x5}; ost == 0)
    {
        cout << "x4 делится на x5" << endl;
    }
    else
    {
        cout << "x4 не делится на x5. Остаток равен " << ost << endl; 
    }

    //Тернарный оператор: операнд1 ? операнд2 : операнд3. Первый операнд представляет условие. Если это условие верно, тогда выполняется второй операнд, иначе - третий операнд.

    int x6 = x4 > x5 ? x4 + x5 : x4 - x5;

    cout << x6 << endl;

    cout << (x4 > x5 ? x4 + x5 : x4 - x5) << endl;

    //Конструкция switch-case позволяет сравнить некоторое выражение с набором значений.

    /*
    switch (выражение)
    {
        case значение1: инструкция1
        case значение2: инструкция2

        case значениеN: инструкцияN
        default: инструкция;
    }
    
    */

    /*
    Сравниваемое выражение в switch должно представлять один из целочисленных или символьных типов, или перечисление.
    default необязателен
    */

    switch(x4)
    {
        case 1:
            cout << "x4 = 1" << endl;
            break; //не забыть поставить break, чтобы выйти из конструкции

        case 2:
            cout << "x4 = 2" << endl;
            break;

        default:
            cout << "x4 = другое" << endl;
    }

    //Совмещение условий. Определить для нескольких меток case один набор инструкций

    switch (x4)
    {
        case 1:
        case 2:
            cout << "x4 = 1 или 2" << endl;
            break;
        
        case 3:
        case 4:
            cout << "x4 = 3 или 4" << endl;
            break;
    }

    //Внутри блоков case можно определять переменные. Если определяется переменная, то конструкцию case надо помещать в фигурные скобки

    switch (x4)
    {
        case 1:
        {
            int a{10};
            cout << a << endl;
            break;
        }
        default:
        {
            int b{20};
            cout << b << endl;
        }
    }

    //Блок switch с инициализацией

    char op = '-';
    int n1 {10};
    switch (int n2 {20}; op)
    {
        case '+':
            cout << n1 + n2 << endl;
            break;
        case '-':
            cout << n1 - n2 << endl;
            break;
    }

    //Циклы

    //Циклы позволяют выполнять некоторый набор инструкций множество раз. for | while | do ... while

    //Цикл while выполняет некоторый код, пока его условие истинно, то есть возвращает true.

    /*
    while (условие)
    {
        //инструкции
    }
    */
   int i {1};
   while (i < 10)
   {
    cout << i << " * " << i << " = " << i * i << endl;
    i++; //не забыть сделать инкремент, чтобы цикл не был бесконечным
   }
   //Если цикл содержит одну инструкцию, то фигурные скобки можно опустить
   int k {};
   while (++k < 10)
    cout << k << " * " << k << " = " << k * k << endl;

   //Цикл for

   /*
   for (инициализатор; условие; итерация)

   инициализатор выполняется один раз при начале выполнения цикла и представляет установку начальных условий, как правило, это инициализация счетчиков, которые контролируют цикл
   (необязательная часть)
   условие представляет условие, при соблюдении которого выполняется цикл. Как правило, в качестве условия используется операция сравнения, и если она возвращает ненулевое значени, то выполняется
   тело цикла.
   (необязательная часть)
   итерация выполняется после каждого завершения блока цикла и задает изменения парамтеров цикла. обычно здаесь происходит увеличение счетчиков цикла
   (необзятальная часть)
   */

   for (int i{1}; i < 10; i++)
   {
    cout << i << " * " << i << " = " << i * i << endl;
   }
   int i1 {1};
   for (; i < 10 ;)
   {
    cout << i1 << " * " << i1 << " = " << i1 * i1 << endl;
    i1++;
   }

   int sum {};
   for (unsigned i {}; i < 6; sum += i++);
   cout << sum << endl;

   for (int i{1}, j{4}; i < 6 && j < 10; i++, j++)
   {
    cout << i << " * " << j << " = " << i * j << endl;
   }

   //Есть специальная форма цикла for для работы с последовательностями значений. 

   /*
   
   for (тип переменная : последовательность)
   {
   
   инструкции

   }
   */

   for (int n:  {2, 3, 4, 5})
   {
    cout << n << endl;
   }
   for (char c: "Hello")
   {
    cout << c << endl;
   }
   //В цикле do сначала выполняется код цикла, а потом происходит проверка условия в конструкции while. И пока это условие истинно, то есть не равно 0, от цикл повторяется. Будет хотя бы однократное выполнение действий

   /*
   
   do
   {
   
    инструкции

   }
   while(условие)
   */
   int i2{6};
   do
   {
    cout << i << endl;
    i--;
   } while (i > 0);
   
   //Вложенные циклы
   for (int i {1}; i < 10; i++)
   {
    for (int j {1}; j < 10; j++)
    {
        cout << i * j << "\t";
    }
    cout << endl;
   }

   //break досрочно завершает работу цикла
   int result {};
   for (int i{1}; i < 10; i++)
   {
    result += i;
    cout << result << endl;
    if (result > 20) break;
   }

   //continue. переходит к следующей итерации и пропускает все инструкции, записанные под ним

   int result1{};
   for (int i{1}; i < 10; i++)
   {
    if (i % 2 == 0) continue;
    result1 += i;
   }
   cout << result1 << endl;

   //Бесконечный цикл

   /*
   for(;;)
   while(true)
   do
   {
   }while(true)
   */

   //Ссылки

   //Ссылка представляет способ манипулировать каким-либо объектом. Фактические ссылка - это альтернативное имя для объекта. Для определения ссылки применяется амперсанд &

   int number1{5};
   int &refNumber1 {number1}; //ссылка refNumber1 ссылается на объект number1

   //int &refNumber1 так сделать нельзя. Обязательно ссылка должна указывать на какой-либо объект
   //int &refNumber1 = 10 так делать нельзя. нельзя присвоить ссылке литеральное значение

   refNumber1 = 20;
   cout << number1 << endl;

   //Изменения по ссылке неизбежно скажутся на том объекте, на который ссылается ссылка.
   //Можно определять не только ссылки на переменные, но и ссылки на константы. При это ссылка сама должна быть константной.

   const int number2{6};
   const int &refNumber2{number2};
   cout << refNumber2 << endl;

   //В большинстве случаев ссылки находят применение в функциях, когда надо передать значения по ссылке.

   int numbers[]{1, 2, 3, 4};
   for (auto n : numbers)
   {
    n = n * n; //здесь работаем с копией
   }
   for (auto n : numbers)
   {
    cout << n << "\t";
   }
   cout << endl;

   for (auto& n : numbers)
   {
    n = n * n; //здесь работаем с самим объектом
   }
   for (auto n : numbers)
   {
    cout << n << "\t";
   }
   cout << endl;

   //Массивы

   //Массив представляет набор однотипных данных. Формальное определение массива: тип_переменной название_массива [длина_массива]

   int numbers2[4]; //массив из 4 чисел

   const int n3 = 4;
   int numbers3[n3]; //размер можно определить через константу

   int numbers4[4] {}; //{0, 0, 0, 0}
   int numbers5[4] {1, 2, 3, 4};

   //В памяти будет выделяться область из четырех ячеек по четыре байта (размер типа int)

   int numbers6[3] {1, 2}; //{1, 2, 0}, если значений в инициализаторе меньше, чем элементов в массиве, то значения передаются первым элементам, а остальные получают нулевые значения

   //Если в инициализаторе будет больше элементов, чем в массиве, то при компиляции будет ошибка int numbers7[3] {1, 2, 3, 4}

   //Если размер не указан явно, то он выводится из количества переданных значений
   int numbers7[] {1, 2, 3, 4, 5, 6};

   //Нельзя присвоить один массив другому
   //int numbers8[] = numbers7;

   int elem1 = numbers7[1];
   cout << elem1 << endl;

   numbers[1] = 4;
   cout << numbers[1] << endl;

   //Внимательно следить за индексами, так как нельзя обратиться по несуществующим

   //Если необходимо, чтобы нельзя было изменять значения элементов массива, то такой массив можно определить как константный
   const int numbers8[] {1, 2, 3, 4};

   //Длина массива

   //1 способ. Как в С:

   cout << sizeof(numbers8) / sizeof(numbers8[0]) << endl;

   //2 способ. size

   cout << size(numbers8) << endl; //size лежит в пространстве имен std

   //Перебор массивов
   for (int i = 0; i < size(numbers8); i++)
   {
    cout << numbers8[i] << endl;
   }

   int sum1 {};
   for(int i {}; i < size(numbers8); sum1 += numbers8[i++]);
   cout << sum1 << endl;

   //for-each

   for (int n : numbers8){
    cout << n << endl;
   }

   //если тип неизвестен, то можно использовать спецификатор auto (пример выше есть)

   //Ввод значений массива с консоли

   const int max {6};
   int numbersMax[max];

   int i3 {};
   cout << "Введите значения" << endl;
   while (i < max)
   {
    cin >> numbersMax[i];
    i++;
   }
   for (auto n : numbersMax){
    cout << n << "\t";
   }
   cout << endl;
   //Многомерные массивы

   //Какждый массив имеет такую характеристику, как размерность. количество размерностей соответствует числу пар квадратных скобок.

   //В многомерных массивах элементы таких массивов сами являются массивами, к оторых также элементы могут быть массивами.

   int numbers9[3][2]; //первая размерность три, вторая - два. Двумерный массив можно представить в виде таблицы, где первая размерность - количество строк, а вторая - количество столбцов
   int numbers10[3][3][2];

   int numbers11[3][2] {};

   int numbers12[3][2]
   {
    {1, 2}, //первая строка
    {4, 5}, //вторая строка
    {7, 8} //третья строка
   };
   //Можно инициализировать не все элементы, а только некоторые

   int numbers13[3][2] {{1, 2}, {}, {7}};

   //При инициализации многомерных массивов можно опустить только первую размерность

   int numbers14[][2] {{}, {}, {}};

   cout << numbers12[0][1] << endl;

   //Перебор многомерного массива. Делается при помощи вложенных циклов

   for (int i = 0; i < 3; i++)
   {
    for (int j = 0; j < 2; j++)
    {
        cout << numbers12[i][j] << "\t";
    }
    cout << endl;
   }

   //Для перебора массивов, которые входят в массив, можем использовать ссылки

   for (auto &subnumbers : numbers12)
   {
    for (int number : subnumbers){
        cout << number << "\t";
    }
    cout << endl;
   }
}