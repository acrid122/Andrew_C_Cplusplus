#include <iostream>
#include <string>
using namespace std;


int n_global {8};
int pp {30};

void hellol()
{
    cout << "hello" << endl;
}

void angry_hello();


void print_n_global()
{
    n_global++;
    cout << "n_global = " << n_global << endl;
}


void print_k()
{
    int k{10}; //локальная переменная, которая существует только в функции print_k
    cout << "k = " << k << endl;

    //cout << "a = " << a << endl; так сделать нельзя, так как a опеределена в функции main
}


void print_d()
{
    static int d {1};
    cout << d << endl;
    d++;
}


void print_man_info(string name, int age)
{
    cout << "Name: " << name << ", Age: " << age << endl;
}


void print_player_info(string, int, string);


void print_lol(string name, int age = 18)
{
    cout << name << " " << age << endl;
}

void sum(auto, auto);

void square(int);

void new_square(int&);

void const_square(int);

void const_square_link(const int&);

int difference(int, int);

int calculate(int, int, char);

void print_man_info2(string, int);

auto multiply(auto m, auto n)
{
    return m * n;
}

int main(){
    //Указатели на константы

    const int a {10}; //локальная переменная, которая существует только в функции main

    //cout << "k = " << k << endl; так сделать нельзя, так как k определена в функции print_k 

    const int *pa {&a};
    //*pa = 36 - не смогу так сделать
    cout << "address = " << pa << "\tvalue = " << a << endl; 
    

    int b {20};
    const int *pb {&b};
    cout << "value = " << *pb << endl;
    b = 40;
    cout << "value = " << *pb << endl;

    //Константые указатели не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу

    int c {30};
    int *const pc {&c};

    cout << "value = " << *pc << endl;

    *pc = 40;
    cout << "value = " << *pc << endl;

    //Константный указатель на константу

    int d {40};

    const int * const pd {&d};

    //*pd = 50; так сделать не получится

    int e {50};
    //pd = &e; так сделать нельзя

    //Указатели и массивы. Обычно компилятор преобразует массив в указатели. С помощью указателе можно манипулировать элементами массива, как и с помощью индексов.

    int nums[] {1, 2, 3, 4, 5};

    cout << "nums[0] adderss: " << nums << endl; //Имя массива является адресом его первого элемента
    cout << "nums[0] value: " << *nums << endl;

    cout << "nums[1] value: " << *(nums + 1) << endl;
    cout << "nums[2] value: " << *(nums + 2) << endl; //Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива.

    for(unsigned i{}; i < size(nums); i++)
    {
        cout << "nums[" << i << "]: address = " << nums + i << "\tvalue= " << *(nums + i) << endl;
    }

    //Имя массива - это нестандартный указатель, и мы не можем изменить его адрес.

    //так сделать нельзя nums++;

    //Указатель на массивы

    const int n = 5;
    int nums1[n] {1, 2, 3, 4, 5};

    for(int *ptr{nums1}; ptr <= &nums1[n - 1]; ptr++)
    {
        cout << "address = " << ptr << "\tvalue = " << *ptr << endl;
    }


    //Указатели на строки и массивы символов

    char hello[] {"hello"};
    char *phello {hello};
    cout << phello << endl;
    cout << *phello << endl;

    //Если необходимо вывести на консоль адрес указателя, то его надо преобразовывать к типу void*

    cout << (void*)phello << endl;

    //Поскольку строковые литералы в С++ рассматриваются как константы, то лучше объявлять указатель на константу const char *phello {"hello"}

    //Массивы указателей

    char languages[][20] = {"C++", "Python", "Pascal"};
    //При данном объявлении необходимо указать размер каждого вложенного массива, что может быть избыточно. Массив указателей решает эту проблему

    cout << languages[0] << ": " << size(languages[0]) << " bytes" << endl;

    const char *languages1[] {"C++", "Python", "Pascal"};

    //Тут каждая из этих строк будет занимать именно то пространство, которое ей непосредственно необходимо. Тут мы получаем общий выигрыш в количестве потребляемой памяти.

    //Определение функции. Функции позволяют выделить набор инструкций и назначить ему имя. Затем многократно по присвоенному имени вызывать этот набор в различных частях программы
    //Функция - именованный блок кода

    /*
    тип имя_функции(параметры)
    {
        инструкции
    }
    */

    //Если функция ничего не возвращает, то используется void в качестве типа
    //Для возвращения результата функция применяет оператор return.
    //Если функция имеет в качестве возвращаемого типа любой тип, кроме void, то она должна обязательно с помощью return возвращать какое-либо значение

    //Стоит отметить, что С++ позволяет не использовать оператор return в main()
    hellol();
    hellol();

    //Никакие другие функции, кроме main, не выполняются автоматически. Для выполнения функции ее необходимо вызвать.

    //имя_функции(аргументы)

    //При использовании функций стоит учитывать, что компилятор должен знать о функции до ее вызова. Поэтому вызов функции должен происходить после ее определения, как в случае выше

    //Если необходимо определить функцию после main, то до main необходимо прописать прототип (фактически - объявление) функции.


    //Область видимости объектов

    //Все переменные имеют определенное время жизни (lifetime) и область видимосте (scope).

    /*
    Время жизни начинается с момента определения переменной и длится до ее уничтожения.

    Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничаивается блоком кода,
    который заключается в фигурные скобки. В зависимости от облатси видимости создаваемые объекты могут быть глобальными, локальными или автоматическими.
    */

    angry_hello();

    //Глобальные объекты

    /*
    Глобальные перменный определены в файле программы вне любой из функций или любого другого блока кода и могут использовать любой функцией.
    Глобальные переменные существуют в течение всей жизни программы и уничтажаются лишь с заверешением программы. Если глобальные переменные не инициализированы, то
    они получают нулевые значения.
    */
    print_n_global();
    n_global++;
    print_n_global();

    //Локальные объекты

    /*
    Локальные объекты существуют только во время выполнения того блока, в котором они определены и являются автоматическими. При входе в блок для подобных переменных
    выделяется память, а после завершения работы этого блока, выделенная память освобождается, а объекты удаляются.
    */

    print_k();

    int n1 {3}; //область видимости - вся функция main

    {
        int n2 {5}; //область видимости - этот блок кода
        cout << n2 << endl;
        n1++; //переменная n1 доступна, так как определена во внешнем контексте - функции/
    }

    //cout << n2 << endl; так нельзя, так как переменная n2 из блока функции уже не существует.
    cout << n1 << endl;
    //Скрытие объектов

    int pp {10};
    cout << pp << endl;
    //Что делать, если очень хочется вывести значение глобальной переменной с таким же названием
    cout << ::pp << endl; //для обращения к глобальной переменной можно использовать оператор :: перед именем переменной

    {
        int pp {20};
        cout << pp << endl;
        cout << ::pp << endl;
    }

    //Статические объекты

    //Кроме автоматических есть особый тип локальных объектов, который называется статический. Они определяются на уровне функций с помощью ключевого слова static.

    /*
    Если автоматические перменные определяются и инициализируются при каждом входе в функцию, то статические переменные инициализируются только один раз, а при
    последующих вызовах функции используется старое значение статической перменной. Автоматические локальные переменные существуют до конца выполнения блока кода,
    в то время как статические локальные переменные - до конца выполнения программы.
    */

    print_d();
    print_d();
    print_d();
    print_d();

    //Параметры функции

    /*
    Через параметры в функцию можно передать различные значения. Параметры перечисляются после имени функции через запятую в скобках.

    (тип_параметра1 имя_параметра1, тип_параметра2 имя_параметра2 ... тип_параметраN имя параметраN)
    */
    print_man_info("Andrew", 19); //аргументы тут передаются по позиции

    //аргументы должны соответствовать параметрам по типу или допускать неявно преобразование в тип параметра. Подобным образом можно передавать в параметры не только
    //литералы, но и, например, значения переменных и констант:

    const string myName {"Gennady"};
    int myAge {22};

    print_man_info(myName, myAge);

    print_player_info("Andrew", 19, "WarThunder");

    //Аргументы по умолчанию
    /*
    Функция может принимать аргументы по умолчанию, то есть некоторые значения, которые функция использует, если при вызове для параметров явным образом
    не передается значение
    */

    print_lol("Andrew", 20);
    print_lol("Gennady");

    //При определении необязательных параметров стоит учитывать, что они должны идти после обязательных

    //Автоматическое вывыедение типа параметров. С С++ 20 можно вместо конкретного типа для параметров указывать ключевое слово auto.
    //Тогда тип параметров будет выводиться автоматически на этапе компиляции на основе передаваемых в функцию аргументов.

    sum(5, 3);

    //Передача аргументов по значению и по ссылке.

    //Передача аргументов по значению. При передаче аргументов по значению функция получает копию значения переменных и констант.

    int m{4};
    cout << "Before square: m = " << m << endl;
    square(m);
    cout << "After square: m = " << m << endl;

    //Так происходит, так как при компиляции функции для ее параметров выделяются отдельные участки памяти. При вызове функции вычисляются значения аргументов, которые
    //передаются на место параметров. И затем значения аргументов заносят в эти участки памяти. То есть функция манипулирует копиями значений объектов, а не самими объектами.


    //Передача по ссылке

    cout << "Before square: m = " << m << endl;
    new_square(m);
    cout << "After square: m = " << m << endl;

    //Ссылочный параметр связывается непосредственно с объектом, поэтому через ссылку можно менять сам объект. Передача по ссылке является более эффективной при передаче 
    //очень больших объектов, поскольку в этом случае не происходит копирования значений, а функция использует сам объект, а не его значение.

    //От передачи аргументов по ссылке следует отличать передачу ссылок в качестве аргументов.

    int &mRef = m; //ссылка на переменную m
    cout << "Before square: m = " << m << endl;
    square(m);
    cout << "After square: m = " << m << endl;

    //Если функция принимает аргументы по значению, то изменение параметров внутри функции также никак не скажется на внешних объектах, даже если при вызове функции
    //в нее передаются ссылки на объекты.

    //Константные параметры

    //Параметры могут быть константыми - значения таких параметров не могут меняться.
    const_square(m);

    //Если не планируется явным образом менять значение параметра, то лучше разу определить его как константный. Константному параметру можно передать в качетве
    //аргументы как константу, так и переменную.

    //Константные ссылки. Значение константной ссылки менять нельзя

    //Оператор return и возвращение результата

    //Две формы: return выражение;
    //return;

    //Возвращаемое значение должно соответствовать возвращаемому типу функции, либо допускать неявное преобразование в этот тип.
    
    cout << difference(5, 6) << endl;

    cout << calculate(5, 6, '+') << endl;
    cout << calculate(5, 6, '-') << endl;
    cout << calculate(5, 6, '*') << endl;
    cout << calculate(5, 6, '/') << endl;

    print_man_info2("Andrew", 19);
    print_man_info2("Gennady", 2000);

    //Выведение типа результат
    cout << multiply(5, 6) << endl; //с прототипом не работает. надо определять функцию целиком до main()
    return 0;
}


void angry_hello()
{
    cout << "I am angry" << endl;
}

void print_player_info(string nickname, int age, string gameName)
{
    cout << "Nickname: " << nickname << ", Age: " << age << ", Favourite game: " << gameName << endl;
}

void sum(auto a, auto b)
{
    auto result = a + b;
    cout << a << " + " << b << " = "<< result << endl; 
}

void square(int m)
{
    m = m * m;
    cout << m << endl;
}

void new_square(int& m)
{
    m = m * m;
    cout << m << endl;
}

void const_square(const int m)
{
    //m = m * m так нельзя делать
    cout << "m * m = " << m * m << endl;
}

void const_square_link(const int &m)
{
    //m = m * m так нельзя делать
    cout << "m * m = " << m * m << endl;
}

int difference(int n, int m)
{
    return n - m;
}

int calculate(int n, int m, char op)
{
    switch (op)
    {
    case '+':
        //break не нужен, так как retrun сразу возвращает результат и выходит из функции
        return n + m;
    case '-':
        return n - m;
    case '*':
        return n * m;
    default:
        return 0;
    }
}


void print_man_info2(string name, int age)
{
    if (age > 120)
    {
        cout << "Incorrect age" << endl;
        return; //выходим из функции
    }

    cout << "Name: " << name << "\tAge: " << age << endl;
}

