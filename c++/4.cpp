#include <iostream>
#include <windows.h>
#include <string>

using namespace std;

int main(){
    // Формальное определение массива: тип_переменной название_масссива [длина_массива]
    int numbers[4]; //число элементов массива можно определеять через константу
    /*
    const n = 4;
    int numbers[n];
    */
   int numbers1[4] {}; //{0, 0, 0, 0}
   int numbers2[4] {1, 2, 3, 4};
   /*
   Если значений в инициализаторе меньше, чем элементов в массиве, то значения преедаются первым элементам, а остальные получают нулевые значения
   */
  int numbers3[4] {1, 2};
  /*
  Если значений в инициализаторе больше, чем элементов в массиве, то при компиляции возникнет ошибка/
  int numbers[4] {1, 2, 3, 4, 5, 6}
  */
 int numbers4[] {1, 2, 3, 4, 5, 6, 7};
    /*
    Нельзя!!

    int numbers1[] {1, 2, 3, 4, 5}
    int numbers2[] = numbers1;
    */
   int num_1 = numbers4[0];
   cout << num_1 << endl;
   /*
   Использование любого индекса, которого нет, приводит к ошибке
   */
  //Константный массив
  const int numbers5[4] {1, 2, 3, 4}; //не могу менять элементы массива
  cout << "Длина: " << sizeof(numbers) / sizeof(numbers[0]) << endl; //размер массива в байтах / размер одного элемента массива
  cout << "Длина через size: " << size(numbers) << endl;

  for (int i = 0; i < size(numbers5); i++)
  {
    cout << numbers5[i] << endl;
  }

  for(int elem : numbers5)
  {
    cout << elem << endl;
  }
  /*
  const int max_size {6};
  int numbers6[max_size];

  int i{};
  cout << "Введите очереденое число для записи в массив" << endl;
  while (i < max_size){
    cin >> numbers6[i];
    i++;
  }
  for(int elem : numbers6)
  {
    cout << elem << endl;
  }
    */
     //Многомерные массивы

   //Какждый массив имеет такую характеристику, как размерность. количество размерностей соответствует числу пар квадратных скобок.

   //В многомерных массивах элементы таких массивов сами являются массивами, к оторых также элементы могут быть массивами.

   int numbers9[3][2]; //первая размерность три, вторая - два. Двумерный массив можно представить в виде таблицы, где первая размерность - количество строк, а вторая - количество столбцов
   int numbers10[3][3][2];

   int numbers11[3][2] {};

   int numbers12[3][2]
   {
    {1, 2}, //первая строка
    {4, 5}, //вторая строка
    {7, 8} //третья строка
   };
   //Можно инициализировать не все элементы, а только некоторые

   int numbers13[3][2] {{1, 2}, {}, {7}};

   //При инициализации многомерных массивов можно опустить только первую размерность

   int numbers14[][2] {{}, {}, {}};

   cout << numbers12[0][1] << endl;

   //Перебор многомерного массива. Делается при помощи вложенных циклов

   for (int i = 0; i < 3; i++)
   {
    for (int j = 0; j < 2; j++)
    {
        cout << numbers12[i][j] << "\t";
    }
    cout << endl;
   }

   //Для перебора массивов, которые входят в массив, можем использовать ссылки

   for (auto &subnumbers : numbers12)
   {
    for (int number : subnumbers){
        cout << number << "\t";
    }
    cout << endl;
   }
   
   //Массивы символов
   char hello1[] {'h', 'e', 'l', 'l', 'o'};
   char hello2[] {"hello"}; //{'h', 'e', 'l', 'l', 'o', '\0'};

   char hello3[] {'h', 'e', 'l', 'l', 'o', '\0'};

   cout << hello1 << endl;
   cout << hello2 << endl;
   cout << hello3 << endl;

   const int max_length{50}; //максимальная длина строки (включая нулевой байт)
   char languages[][max_length]
   {
    "C++", "C#", "Python", "Java",
    "Kotlin",  "Go", "Dart", "Ruby", 
    "PHP", "Swift", "Pascal", "F#"
   };
   cout << languages[0] << endl;
   cout << languages[1][1] << endl;
   cout << languages[5][0] << endl;

   //Перебор двумерных символьных массивов

   for (auto lang : languages)
   {
    cout << lang << endl;
   }

   //Вводи символьных массивов/строк с консоли
   /*getline() - функция потока cin, которая считывает последовательность символов, включая пробелы. По умолчанию ввод заканчивается, когда считывается символ перевода строки
   '\n. Функция getline() имеет две версии. Первая версия принимает два параметра: первый укаызвает на массив символов для хранения введенных данных, а второй указывает
   на максимальное количество символов, которое надо сохранить в массиве. Это количество включает символ заверешния строки - нулевой байт '\0'.
   */
  /*
  const int max_length2 {100};
  char text[max_length2] {};
  
  cout << "Введите какой-то текст" << endl;
  cin.getline(text, max_length2);
  cout << "Введенный текст: " << text << endl;

  Другая форма функции getline() также принимает третий параметр - символ, который будет выступать сигналов завершения ввода

  const int max_length3 {100};
  char text2[max_length3] {};
  cout << "Введите какой-то текст" << endl;
  cin.getline(text2, max_length3, '!');
  cout << "Введенный текст: " << text2 << endl;
  */

   string message; //определение пустой строки

   string message2 {"Hello, world!"};
   string message3 = "Hello, world 2 !";
   string message4 = ("Hello world 3!");


   /*
   Работать с массивами символов в C++ лучше через string нежели, чем через С-массивы. Это безопаснее, так как при различных манипуляциях вероянтность ошибки при
   работе с C-массива кратно выше.
   */

   cout << message2 << endl;
   //Получение и изменения символов строки
   char c {message2[0]};

   message2[0] = 'M';
   cout << message2 << endl;

   unsigned count{};

   for (auto c : message2)
   {
    if (c == 'l')
    {
        count++;
    }
   }
   cout << "Количество букв l в message2: " << count << endl;

   //Чтение строки с консоли
   /*
   string name;
   cin >> name;
   cout << "Имя: " << name << endl;
    
   //Но если при вводе строка будет содержать подстроки, разделенные пробелом, то cin будет использовать только первую подстроку, поэтому считываем при помощи getline()

   string name2;
   cout << "Введите имя и фамилия через пробел: " << endl;
   getline(cin, name2); //метод getline принимает 2 объекта: cin - поток ввода и переменную, в которую надо считать
   cout << "ФИ: " << name2 << endl;
   */

   //Указатели

   /*Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций.
   Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указателя обладают большими возможностями
   */

   //Определение указателя: тип_данных* название_указателя

   //Указатель на объект типа int

   int* p; //такой указатель может хранить только адрес переменой int, но пока данный указатель не сылается ни на какой объект, то он хранит случайное значение
   cout << p << endl;

   int* p2{}; //Поскольку конкретное значение не указано, указатель в качестве значения получает число 0. Это значение представляет специальный адрес, который не указывает ни на что

   int* p3{nullptr};

   //В общем случае указатели следует инициализировать каким-то конкретным значением или нулем.

   //int* p1 = int *p1. положение указателя ни на что не влияет

   //Размер указателя (хранимый адрес) не зависит от типа указателя, а зависит от конкретной платформы. На 32-разрядных платформах размер адресов равен 4 байтам, а на 64 - 8 байтам.

   int* pint{};
   double* pdouble{};
   cout << "*pint size: " << sizeof(pint) << endl;
   cout << "*pdouble size: " << sizeof(pdouble) << endl;

   //Получение адреса и оператор &

   int number {25};
   int* pnumber{&number}; //указатель pnumber хранит адрес переменной number. & - позволяет получить адрес некоторого объекта. Должно быть соотвествие по типам

   //Однако можно использовать auto
   //auto* pnumber{&number};

   cout << pnumber << endl; //0x5ff8ec 0x5ff8ed 0x5ff8ee 0x5ff8ef - эти ячейки будут заняты, так как number занимает 4 байта.
   cout << &pnumber << endl; //0x5ff8e0 

   //Получение значения по адресу

   //* - разыменовывание - получение значения переменной через указатель

   cout << *pnumber << endl;

   //Смена значения по адресу, который хранится в указателе
   *pnumber = 40;
   cout << number << endl;

   //Операции с указателями

   //Присваивание адреса

   int a {10};
   int* pa{&a}; //указатель pa хранит адрес переменной a

   //Разыменование указателя

   cout << *pa << endl;

   *pa = 15;

   cout << a << endl;

   //Присвоение указателю другого указателя

   int a1{10};
   int b1{10};

   int* pa1{&a1};
   int* pb1{&b1};

   pa1 = pb1; //теперь указатель pa1 хранит адрес переменной b1

   *pa1 = 100;

   cout << b1 << endl;

   //Нулевые указатели (смотреть выше)

   //Ссылки на указатели

   /*
   так как ссылка ее является объектом, то нельзя определить указатель на ссылку, однако можно определеить ссылку на указатель. Через подобную ссылку
   можно изменять значение, на которое указывает указатель или изменять адрес самого указателя.
   */

   int a2{10};
   int b2{6};

   int *p0{}; //указатель

   int *&pRef {p}; //ссылка на указатель

   pRef = &a2; //через ссылку указателю p присваивается адрес переменной a2

   cout << *p << endl;

   *pRef = 70; //изменяется значение по адресу, на который указывает указатель

   cout << a2 << endl;

   pRef = &b2; //изменяется адрес, на который указывает указатель

   cout << *p << endl;

   //Адрес указателя

   //Адрес указателя

   cout << &pa1 << endl;

   //Адрес, который хранится в указателе - адрес переменной a1

   cout << pa1 << endl;

   //Значение по адресу в указателе - значение переменной a1

   cout << *pa1 << endl;

   //Операции сравнения. Они применяются только к указателям одного типа. Для сравнения используются номер адресов.

   if (pa1 > pb1)
   {
    cout << "pa1 (" << pa1 << ") больше, чем pb1 (" << pb1 << ")" << endl;
   }
   else
   {
    cout << "pb1 (" << pb1 << ") больше или равно, чем pa1 (" << pa1 << ")" << endl;
   }

   //Приведение типов

   //тип_указателя *

   char c1 {'N'};
   char *pc1 {&c1}; //указатель на символ

   int *pd1 {(int* ) pc1}; //указатель на int
   void *pv1 {(void*) pc1}; //указатель на void

   cout << pd1 << endl;
   cout << pv1 << endl;

   //Арифметика указателей

   //Сложение, вычитание, инкремент, декремент. Сами операции производятся немного иначе, чем с числами. Много зависит от типа указателя.

   int d{10};
   int* pd{&d};

   cout << "адрес: " << pd << " значение: " << *pd << endl;
   pd++; //увеличение на единицу означает увеличение адреса, который хранится в указателе на размер типа указателя
   cout << "адрес: " << pd << " значение: " << *pd << endl;
   pd--;
   cout << "адрес: " << pd << " значение: " << *pd << endl;

   double dd{10.6};
   double *pdd{&dd};
   cout << "адрес: " << pdd << " значение: " << *pdd << endl;
   pdd++; 
   cout << "адрес: " << pdd << " значение: " << *pdd << endl;
   pdd--;
   cout << "адрес: " << pdd << " значение: " << *pdd << endl;

   short sh{5};
   short *psh{&sh};
   cout << "адрес: " << psh << " значение: " << *psh << endl;
   psh++; 
   cout << "адрес: " << psh << " значение: " << *psh << endl;
   psh--;
   cout << "адрес: " << psh << " значение: " << *psh << endl;

   pdd = pdd + 2; //увеличение на 16 байт, так как работаем с двумя объектами double
   cout << "адрес: " << pdd << " значение: " << *pdd << endl;
   pdd = pdd - 3;
   cout << "адрес: " << pdd << " значение: " << *pdd << endl;

   psh = psh + 3; //увеличение на 6 байт, так как работаем с тремя объектами short
   cout << "адрес: " << psh << " значение: " << *psh << endl;

   /*
   В отличие от сложения операция вычитания может применяться не только к указателю и целому числу, но и к двум указателям одного типа:
   */

   int a3 {10};
   int b3 {20};

   int *pa3 {&a3};
   int *pb3 {&b3};

   auto ab3 {pa3 - pb3};

   cout << pa3 << endl;
   cout << pb3 << endl;
   cout << ab3 << endl;

   //результатом разности двух указателей является расстояние между ними.
   //расстояние = (разность адресов) / размер одного объекта. (0x5ff840 - 0x5ff83c) / 4 = 4 / 4 = 1

   /*
   При работе с указателями надо отличать операции с самим указателем и операции со значением по адресу, на который указывает указатель.
   */

   int a4 {10};
   int* pa4 {&a4};
   int b4 {*pa4 + 20}; //операция со значением, на который указывает указатель
   pa4++; //операция с самим указателем

   cout << b4 << endl;

   //*  и операции ++ / -- имеют одинаковый приоритет и выполняются справа налево

   int a5 {10};
   int *pa5 {&a5};

   cout << "адрес: " << pa5 << " value: " << *pa5 << endl;

   int b5 {++*pa5}; //инкремент значения по адресу указателя

   cout << b5 << endl;
   cout << "адрес: " << pa5 << " value: " << *pa5 << endl;
}