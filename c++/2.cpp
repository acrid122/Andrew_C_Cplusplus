#include <iostream>

using std::cin;
using std::cout;
using std::endl;
//using используется для определения псевдлнимов
using ullong = unsigned long long;
typedef unsigned long long ullong2;

using namespace std;

int main() {

    ullong2 num00 {1233123};
    ullong num0 {1023123};
    /*
    Все целочисленные литералы хранятся в 10СС. Однако С++ также позволяет использовать числа в других СС.

    Для 16 СС перед числом указывать префикс 0x/0X
    Для 8 СС перед числом указывать 0
    Для 2 СС бинарные литералы представляются при помощи 0b/0B
    */
   int num1 {0x1A};
   int num2 {025};
   int num3 {0b1010100};
   std::cout << num1 << " " << num2 << " " << num3 << std::endl;

   /*
   Для хранения дробных чисел в С++ применяются числа с плавающей точкой. Число с плавающей точкой состоит из двух частей: мантиссы и показателя степени.
   */

   //3.650000E02. Мантисса имеет 7 десятичных цифр - 3.650000, показатель степени - две цифры 02. Буква E обозначает экспоненты, после нее указывается показатель степени. -3.650000E-03.

   /*
   float: -3.4E-38 до 3.4E+38. В памяти 4 байта
   double: 8 байтов. -1.7E-308 до 1.7E+308
   long double

   _ - бит знака _ _ _ _ _ - биты степени _ _ _ _ ... - биты мантиссы. 8 бит для экспоненты, 23 для мантиссы и 1 бит знак. 32 бита (float)
   */
  double num4 {10.45};

  double num5 {1.}; //все равно double

    /*
    Символые типы:

    char - 1 символ в кодировке ASCII. занимает 1 байт
    wchar_t - представляет символ. 2 байта на винде, 4 байта на линуксе. основной тип, предназначенный для символов , размер которых выходит за пределы 1 байта wide char
    char8_t - 1 символ из кодировки Unicode занимает 1 байт
    char16_t - 1 символ из кодировки Unicode занимает 2 байт
    char32_t - 1 смивол из кодировки Unicode занимает 4 байт

    Переменная типа char хранит числовой код одного символа.
    */
    char a1 {'A'};
    char a2 {65};
    wchar_t a3 {L'A'};


    /*
    auto - спецификатор, которые позволяет компилятору самому выводить тип объекта
    */
   auto number = 5;
   std::cout << number << std::endl;


   //Константа - const

   const int num6 {22}; //если константа не будет инициализирована, то будет ошибка
   const int num7 {number};
   
   //istream - поток ввода, ostream - поток вывода. под потоком подразумевается последовательность символов, которая записывается на устройство ввода-вывода (консоль) или считывается с него.

   //<<

   //std::endl - переход на новую строку и сброс буфера

   int num8, num9;

   //std::cin >> num8 >> num9;
   //std::cout << num8 << " " << num9 << std::endl;

   /*
   Объекты cout, cin, endl определены в пространстве имен std. std:: - префикс. :: - оператор области видимости, который позволяет указать, в каком пространстве име определен объект.

   Можно использовать оператор using, который позволяет ввести в программу объекты из различных пространств имен.

   using пространство_имен::объект
   */

   /*
   Арифметические операции
   */

   //+

   int num10 {8};
   int num11 {10};

   int num1011 {num10 + num11};

   cout << num1011 << endl;

   //-

   int num1110 {num10 - num11};
   cout << num1110 << endl;

   //*
   cout << num10 * num11 << endl;

   // /

   cout << num10 / num11 << endl;

   /*
   При делении если участвуют два целых числа, то дробная часть отбрасывается, даже если результать присвоить переменной float или double. Если надо, чтобы результат представлял число с плавающей точкой, один
   из операндов также должен представлять число с плавающей точкой.
   */

   //%

   cout << num11 % num10 << endl;

   //Некоторые особенности при работе с числами с плавающей точкой

   /*
   3.65E+6 (3650000), 1.23E-4 (0.000123)
   3650000,000123.
   */

   double num12 {3.65E+6};
   double num13 {1.23E-4};

   cout << num12 + num13 << endl; // не изменилось, так как для хранения точно отводится 7 цифр

   //IEEE (754)

   //NaN - значение, которое предствляет результат операции, которые не определяется математически, например, деление на 0 или бесконечность на бесконечность

   double b{}, c{};
   cout << b / c << endl;
   cout << -1 / c << endl;
   cout << 1 / c << endl;

   //Инкремент ++ | декремент --

   //Префиксный инкремент: увеличивает значение переменной на единицу и полученный результат используется как значение выражение ++x (префиксный декремент)

   int num14 {8};
   int num15 {++num14}; 

   cout << num14 << endl;
   cout << num15 << endl;

   //Постфиксный инкремент: увеличивает значение переменной на единицу, но значением выражение x++ будет то, которое было до увеличения на единицу (постфиксный инкремент)
   int num16 {8};
   int num17 {num16++};

   cout << num16 << endl;
   cout << num17 << endl;

   //Приоритет и ассоциативность

   //Левоассоциативные - операторы, которые выполняются слева направо, правоассоциативными - выполняются справа налево.
   //++, --, * | / | %, + | -

   int a = 8;
   int b1 = 7;
   int c1 = a + 5 * ++b1;
   cout << c1 << endl;


   //Статическая типизация и преобразования типов

   //если мы определили для переменной какой-то тип данных, то впоследствии этот тип изменить нельзя

   //Примеры неявных преобразований

   bool a22 = 1; //true
   bool a33 = 0; //false
   bool a4 = 'a'; //true

   int b2 = true; //1
   int b3 = false; //0

   int c2 = 3.4; //3
   int c3 = 4.432432; //4

   //переменной, которая представляет тип с плавающей точкой присваивается целое число. в этом случае, если целое число содержит больше бито, чем
   //может вместить тип переменной, то часть информации усекается.

   float a5 = 35005; //35005
   double b5 = 3578362178361; //3.5783e+12

   //переменной безнакового типа присваивается значение не из его диапазона.

   //unsigned char 0 - 255. в этом результате будет остаток от деления по модулю (5 % 256)
   unsigned char a6 = -5; //251

   //в арифметических операциях необходимо, чтобы оба операнда представляли один и тот же тип. если операнды имеют разные типы, то компилятор автоматически выбирает операнд с типом, который имеет меньший
   //диапазон значений и пытается его преобразовать в тип второго операнда, который имеет больший диапазон.

   //те преобразования, при который не происходит потеря информации, называется безопасной.

   //явные преобразования

   //явные преобразованя применяются при помощи оператора static_cast: static_cast<type>(value), static обозначает, что приведение проверяется статически, то есть во время компиляции.

   double sum {112.5};
   unsigned int hours {10};
   unsigned int salPerHour {static_cast<unsigned int>(sum / hours)};
   cout << salPerHour << endl;

   //поразрядные операции -> ./c/zan2.c -> 190 строка

   //операции присваивания: =. имеют правосторонний порядок, поэтому выполняются справа налево

    a2 = a3 = a4 = 30;

    /*
    +=, -=, *=, /=, %=, <<=, >>=, &=, |=, ^=
    */

    //Условные выражения. К условным выражения относятся операции сравнения и логические операции

    /*
    операции сравнения
    ==, >, <, >=, <=, !=
    */

    int a7 {8};
    int b7 {8};
    bool c8 {a7 == b7};
    cout << c8 << endl;
    //если очень хочется вывести именно true/false
    cout << boolalpha << c8 << endl; //boolalpha - манипулятор

    /*
    логические операции
    !, &&, ||, ^
    ! - not
    && - И
    || - ИЛИ
    ^ - XOR
    */

    bool a9 {true};
    bool b9 {true};

    cout << boolalpha << !a9 << endl;
    cout << boolalpha << (a9 && b9) << endl;
    cout << boolalpha << (a9 || b9) << endl;
    cout << boolalpha << (a9 ^ b9) << endl;

    //Операции сравнения имеют больший приоритет, чем логические.

    //&&, || представляют операторы сокращенного вычисления. Это значит, что если первый операнд операции достаточен для того, чтобы определить результат всей опеарции, то второй операнд не вычисляет

    // 1 > 0 || 2 > 5
   return 0;
}