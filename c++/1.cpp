#include <iostream>
/*
Данная строка представляет директирову препроцессора, которая позволяет подключить библиотеку iostream. Эта библиотека нужна для вывода строки в консоль.
Признаком завершения директивы препроцессора является перевод на новую строку. Директива должна начинаться со знака #.
*/
#include <windows.h>

/*
Функция main должна присутствовать в любой программе на С++. С нее и начинается выполнение приложения.
Тип возвращаемого значения. В данном случае это тип int. Этот тип указыывает, что функция должна возвращать целое число.
Имя функции - main
Список параметров. После имени в скобках идет список параметров. 
Тело функции. После списка параметров в фигурных скобках идет тело функции.
*/

int x;


int main() {
    /*
    Явным образом задаем текущую локаль для вывода символов.
    */
    setlocale(LC_ALL, "");
    /*
    Язык программирования С++ предствляет высокоуровневый компилируемый язык программирования общего назначения со статической типизацией.

    Системное программирование.

    С++ является комплируемым языком. Это означает, что компилятор транслирует исходный код на С++ в исполняемый файл, который содержит набор машинных инструкций.

    В отличие от Си язык С++ позволяет писать приложения в объектно-ориентированном стиле, представляя программу как совокупнгость взаимодействующих между собой
    классов и объектов.
    */

    /*
    Вывод строки в консоль. Для обращения к консоли используется стандартный поток вывода std::cout. С помощью оператора << в этот поток передается строка символов, котору. надо
    вывести, то есть Hello.

    std::endl - переход на новую строку
    */
    std::cout << "Hello" << std::endl;  // вывод суммы
    std::cout << "Hello" << " " << "World" << std::endl;
    SetConsoleOutputCP(65001); //UTF-8 (не нужно, если файл и так в UTF-8)
    std::cout << "Привет" << std::endl; //Выводить обычный UTF-8
    std::cout << u8"Привет" << std::endl; //u8 - указание кодировки

    
    /*
    Выход из функции с помощью оператора return.

    После каждой инструкции в языке C++ ставится точка с запятой.

    Комментарий не учитывается при компиляции приложения и не является частью программного кода.
    */

    /*
    Программа на С++ состиот из набора инструкций. Каждая инструкция выполняет определенное действие. В конце инструкции ставится ;. Данные знак
    указывает компилятору на завершение интсрукции.
    */

    {
        std::cout << "Привет" << std::endl; //Выводить обычный UTF-8
        std::cout << u8"Привет" << std::endl; //u8 - указание кодировки
    }

    /*
    int main (int argc, char * argv[])
    {
    
    }
    */

    /*
    Создание исполняемого файла из исходного кода на С++ состоит из 3 этапов:

    1) Препоцессора обрабатывает все директивы препроцессора

    2) Компилятор обрабатывает каждый файл с исходным кодом и создает из него объектный файл, которые содержит машинный код.
    Например, код может быть разбросан по нескольким файлам с исходным кодом и для каждого файла будет создан объектный файл

    3) Компоновщик объединяет все объектные файлы в единую программу (процесс компоновка)

    .cpp файл -> компилятор -> объектый файл -> компоновщик -> файл программы
    */

    /*
    Для хранения данных в языке С++ используются переменные. Переменные предствляют именованный участок памяти. Переменная имеет тип, имя, значение. Тип определяет, какие
    именно данные может хранить переменная.
    
    тип_переменной имя_переменной;

    Именование переменных

    Имя переменной должно начинаться с алфавитного символа или _. Нельзя использовать ключевые слова, например, for/if. Следует отметить, что не рекомендуется следующее:

    начинать имя переменной с двух подчеркиваний
    с подчеркивания, после которого идет заглавный символ
    имена в глобальной области (вне функции main) не должны начинаться _
    */

    int age; //int Age - переменные разные, так как с++ регистрозависимый

    /*
    Инициализация

    Присвоение переменной начального значения называется инициализацией. В с++ есть три вида:

    Нотация присваивания
    Функциональная нотация
    Инициализация в фигурных скобках
    */

    //Нотация присваивания - с помощью оператора присваивания (=) передаем переменной некоторое значение.
    age = 20;

    std::cout << "age = " << age << std::endl;

    int Age = 28;

    std::cout << "Age = " << Age << std::endl;

    //Инициализация в фигурных скобках. После названия переменной в фигурных скобках указывается значение.

    int age_1 {age + 30 + 8 + 8 / 2};
    std::cout << "age_1 = " << age_1 << std::endl;

    //Функциональная реализация. После названия переменной в круглых скобках указывается значение

    int age_2 (age + 30 + 8 + age_1 / 2);
    std::cout << "age_2 = " << age_2 << std::endl;

    int age_3 = 23, age_4 {24}, age_5 (25);

    std::cout << "age_3 = " << age_3 << " " << "age_4 = " << age_4 << " " << "age_5 = " << age_5 << std::endl;

    //Сужающее преобразование изменяет значение одного типа на тип с более ограниченным диапазоном значенией. 

    int age_6 (23.5);
    int age_7 = 24.5;

    std::cout << "age_6 = " << age_6 << std::endl;
    std::cout << "age_7 = " << age_7 << std::endl;

    /*int age_8 {23.5};
    std::cout << "age_8 = " << age_8 << std::endl;
    /error: narrowing conversion of '2.35e+1' from 'double' to 'int' [-Wnarrowing] 140 |     int age_8 {23.5}; 
    */

    //Инициализация нулем

    int age_9 {};

    //Инициализация по умолчанию

    int y;
    std::cout << "X = " << x << std::endl; //переменная x определена вне функции, поэтому она получит значение по умолчанию - число 0.
    std::cout << "Y = " << y << std::endl; //многое будет зависить от используемого компилятора. так лучше не делать, так как в другом компиляторе будет другое значение (скорее всего)

    x = 1;
    std::cout << "X = " << x << std::endl; 
    x = 46237846;
    std::cout << "X = " << x << std::endl; 

    /*
    Логический тип:

    Может хранить одно из двух значений: true, false. 

    При выводе значений типа boll преобразуются в 1 (если true) и 0 (если false). Как правило, данный тип применяется преимущественно в условных выражениях.
    */

    bool isAlive {true};
    bool isDead {false};

    std::cout << "isAlive: " << isAlive << std::endl;
    std::cout << "isDead: " << isDead << std::endl;

    /*
    Целочисленный тип:

    signed char: представлет один символ. Занимает в памяти 1 байт. Может хранить любое значение из диапазона от -128 до 127

    unsigned char: представляет один символ. Занимает в памяти 1 байт. Может хранить любое значение из диапазона от 0 до 255.

    char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт. Может хранить любое значение из диапазона от -128 до 127 или от 0 до 255.

    Тип char предназначен для хранения числового кода символа и в реальности может представлять как signed char, так и unsigned char в зависимости от конкретного компилятора.

    short: представляет целое число в диапазоне от -32768 до 32767. Занимает в памяти 2 байта. Псевдонимы: short int, signed short int, signed short.

    unsigned short: представляет число в диапазоне от 0 до 65535. Занимает в памяти 2 байта.

    int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 или 4 байта. Диапазон предельных значений варьируется от -32768 до 32767 (2 байта) или от 
    -2 147 483 648 до 2 147 483 647 (при 4 байтах). В любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long.

    unsigned int: представляет целое положительное число. 2 байта/4 байта в зависимости от архитектуры. 0 до 65535 - 2 байта. 0 - 4 295 967 295 - 4 байта.

    long: в зависимости от архитектуры может занимать 4 или 8 байт. -2 147 483 648 до 2 147 483 647 (при 4 байтах) или от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 (при 8 байтах)

    unsigned long: 0 до 4 294 967 295.

    long long: число в диапазоне от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.

    unsigned long long: число в диапазоне от 0 до 18 446 744 073 709 551 615.

    Есть 2 архитектуры: 32-битная/64-битная.

    Архитектура показывает как устроен процессор и память: сколько бит он обрабатывает за раз и т.д.
    */

    signed char num1 {-64};
    unsigned char num2 {64};
    short num3 {-90};
    unsigned short num4 {90};
    int num5 {-1024};
    unsigned int num6 {1024};
    long num7 {-2048};
    unsigned long num8 {2048};
    long long num9 {-4096};
    unsigned long long num10 {4096};

    std::cout << "num1 = " << num1 << std::endl;
    std::cout << "num2 = " << num2 << std::endl;
    std::cout << "num3 = " << num3 << std::endl;
    std::cout << "num4 = " << num4 << std::endl;
    std::cout << "num5 = " << num5 << std::endl;
    std::cout << "num6 = " << num6 << std::endl;
    std::cout << "num7 = " << num7 << std::endl;
    std::cout << "num8 = " << num8 << std::endl;
    std::cout << "num9 = " << num9 << std::endl;
    std::cout << "num10 = " << num10 << std::endl;

    long long num11 {-4096LL};
    /*
    U/u - unsigned int
    L/l - long
    UL/ul - unsigned long
    LL/ll - long long
    ULL/ull - unsigned long long

    Использовать суффиксы необзятально, поскольку, как правило, компилятор может успешно преобразовывать целочисленный литерал типа к нужному типу без потери информации.
    */

    /*
    Если число большое, то при вводе можно упростить читабельность. Начиная с С++ 14 стандарта была добавлена возможность разделения разрядов числа с помощью одинарной кавычки
    */

    int num12 {1'234'567'890};
    std::cout << "num12 = " << num12 << std::endl;
    return 0;
}
