#include <stdio.h>
#include <locale.h>
int main(void){
    setlocale(LC_ALL, "ru_RU.UTF-8");
    //Динамическая установка размера массива
    int maxSize = 3;
    int array[maxSize];
    array[0] = 1;
    array[1] = 2;
    array[2] = 3;
    for (int i = 0; i < maxSize; i++){
        printf("%d\n", array[i]);
    }
    /*
    int maxSize = 3;
    int array[maxSize] = {1, 2, 3};
    Нельзя при динамической установке инициализироать массив
    */
    //Константный массив
    const int numbers[2] = {1, 2};
    //numbers[0] = 10; нельзя изменить - массив константый
    printf("%d\n", numbers[0]);

    //Двумерные массивы    
    int numbers1[3][2] = { {1, 2}, {3, 4}, {5, 6} };
    /*
      0 1
    0 1 2
    1 3 4
    2 5 6
    */
    printf("%d \n", numbers1[1][0]);

    //Трехмерные массивы
    int numbers2[3][2][1] = { {{1}, {2}}, {{3}, {4}}, {{5}, {6}} };

    for (int i = 0; i < 3; i++){
        for(int j = 0; j < 2; j++){
            printf("numbers1[%d][%d] = %d \n", i, j, numbers1[i][j]);
        }
    }

    //Поиск количества элементов в строчках и столбцах при помощи size_t
    size_t rows_count = sizeof(numbers1) / sizeof(numbers1[0]);
    size_t cols_count = sizeof(numbers1[0]) / sizeof(numbers1[0][0]);
    for (size_t i = 0; i < rows_count; i++){
        for(size_t j = 0; j < cols_count; j++){
            printf("numbers1[%zu][%zu] = %d \n", i, j, numbers1[i][j]);
        }
    }

    //Все многомерные массивы - абстракция, которая в реальность не существуеть. В реальности все массивы являются одномерными и представляют сплошной блок памяти.
    int numbers3[3][2] = {1, 2, 3, 4, 5, 6};
    /*
    missing braces around initializer [-Wmissing-braces]
    53 |     int numbers3[3][2] = {1, 2, 3, 4, 5, 6};
      |                          ^
      |                           {   } {   } {   }
    */
    for (int i = 0; i < 6; i++){
        printf("numbers3[%d] = %d \n", i, numbers3[i]);
    }

    //Строки
    //Для представления строк используют массивы символов
    char message[] = "Hello";
    printf("message: %s \n", message);

    //Каждая строка в качестве завершающего символа содержит символ \0 или нулевой символ. Это первый символ из таблицы ASCII. Hello\0

    size_t length = sizeof(message) / sizeof(message[0]);
    for (size_t i = 0; i < length; i++){
        printf("%d \n", message[i]);
    }

    //Если определять массив message именно как массив символов, то нулевой символ обязательно писать в конец
    char message1[] = {'H', 'e', 'l', 'l', 'o', '\0'};

    int matrix1[3][2] = { {1, 2}, {3, 4}, {5, 6} };
    int matrix2[2][1] = { {10}, {20} };
    int matmult[3][1] = {{0}, {0}, {0}}; //инициализируем результирующую матрицу нулями, так как на первой итерации сразу будем прибавлять значение произведения

    for (int i = 0; i < 3; i++){
        for (int k = 0; k < 1; k++){
            for (int j = 0; j < 2; j++){
                matmult[i][k] += matrix1[i][j] * matrix2[j][k];
                /*
                matmult[0][0] += matrix1[0][0] * matrix2[0][0] = 1 * 10 = 10
                matmult[0][0] += matrix1[0][1] * matrix2[0][1] = 10 + 2 * 20 = 50
                matmult[1][0] += matrix1[1][0] * matrix2[1][0] = 3 * 10 = 30
                ...
                */
            }
        }
    }
    /*
    1 2             50
    3 4  * 10 20    110
    5 6             170

    3 2     2 1  = 3 1
    */
    for (int i = 0; i < 3; i++){
        for(int j = 0; j < 1; j++){
            printf("matmult[%d][%d] = %d \n", i, j, matmult[i][j]);
        }
    }

    //scanf() - для ввода данных функция
    //scanf(форматная строка, аргументы); форматная строка - % * ширина_поля модификатор спецификатор. Обязательны - %, спецификатор
    /*
    %c - считывает один символ
    %d - считывает десятичное число
    %i - считывает число в любой системе счисления
    %u - считывает положительное целое число
    %e - считывает число с плавающей точкой в экспоненциальной форме
    %f - считывает число с плавающей точкой
    %o - считывает восьмиричное чисол
    %x - считывает шестнадцатеричное число
    %s - считывает строку
    %% - считывает символ процента
    */
   /*
   * позволяет пропустить при вводе вводимые символы для типа, указанного через спецификатор
   ширина_поля определяет какое количество байтов учитывать при вводе
   модификатор позволяет конкретизировать тип данных

   h: для ввода значений типа short int
   l: для ввода значений типа long int/double
   L: для ввода значений типа long double
   */
  // В качестве аргументов в функцию scanf передают адреса переменной, которая будет получать введенное значение. Чтобы получить адрес, надо перед ее названием поставить знак &.
  /*
  int age;
  printf("Введите возраст: ");
  scanf("%d", &age);
  printf("age = %d \n", age);
  

  int count;
  double price;
  long code;
  printf("Информация о товаре: ");
  scanf("%ld %lf %d", &code, &price, &count);
  printf("Код продукта: %ld \t цена: %lf \t количество: %d \n", code, price, count);

  char name[10];
  printf("Ввести имя: ");
  scanf("%10s", name); //название массива представляет ссылку на первый элемент массива
  printf("%s \n", name);
  */

  //Указатели
  /*
  Все определенные в программе данные хранятся в памяти по определенному адресу. Указатели позволяют напрямую обращаться к этим адресам и благодаря этому
  манипулировать данными. Указатели предствляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций.
  
  Для определения указателя надо указать тип объекта, на который указывает указатель и символ *
  тип_данных * название_указателя

  int *v - указатель на объект типа int
  */
  int x = 10; //определяем переменную
  int *v; //определяю указатель
  v = &x; //указатель получает адрес переменной

  /*
  Еще раз: указатель хранит адрес объекта в памяти компьютера. Для получения адреса к переменной применяется операция &. Эта операция применяеися только к таким объектам,
  которые хранятся в памяти компьютера, т.е к переменным и элементам массива. 

  У указателя и переменной, на которую указатель указывает, должен быть один и тот же тип (в данном случае int). Для адресов в памяти применяется 16 СС.
  */
  printf("%p \n", v);

  /*
  Значение занимает 4 байта, так как int.
  Таким образом, значение займет следующие адреса:
  00000000005FFD14 - 1 байт, 00000000005FFD15 - 2 байт, 00000000005FFD16 - 3 байт, 00000000005FFD17 - 4 байт.
  */
  printf("%p \n", (void *) v); //канонически верно

  /*
  Так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется операция * (операция разыменования).
  Результатом этой операции всегда является объект, на который указывает указатель.
  */
  printf("x = %d \n", *v);


  //Используя полученное значение в операции разыменования, мы можем присвоить его другой переменной
  int y = *v;
  printf("y = %d \n", y);

  //Также используя указатель, мы можем менять значение по адресу, который хранится в указателе

  //Через *pa мы можем получить значение по адресу, который хранится в указателе pa, а через выражения типы *pa = значение вложить по этому адресу новое значение.
  *v = 100;
  printf("x = %d \n", x);

  char c = 'B';
  int d = 20;
  short i = 80;

  //лучше указатели называть как: *pc, где c - название переменной
  char *pc = &c;
  int *pd = &d;
  short *pi = &i;

  printf("c: адрес = %p \t значение: %c \n", pc, *pc); 
  printf("d: адрес = %p \t значение: %d \n", pd, *pd);
  printf("i: адрес = %p \t значение: %hd \n", pi, *pi);

  /*
  00000000005FFD0E 00000000005FFD0F 00000000005FFD10 00000000005FFD11 00000000005FFD12 00000000005FFD13 00000000005FFD14 00000000005FFD15 00000000005FFD16 00000000005FFD17 
        short занимает 2 байта                          int занимает 4 байта                                                                              char занимает 1 байт

  -----------------i---------------|---------------------------------d---------------------------------|                                                  |-------c--------|
  */


  //Операции с указателями

  /*
  Указателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя, либо константу NULL
  */

  int a = 10, b = 2;
  int *pa = &a, *pb = &b;
  pa = pb; //теперь указатель pa хранит адрес переменной b

  //Если не хочется, чтобы указатель указывал на какой-то конкретный адрес, то пишем NULL
  int *px = NULL;

  //Указатель на void

  /*
  Можно определять указатели типа void*, которые могут указывать на данные любого типа. И неявно указатели любых типов преобразовывать в указатели типа void*
  */


  int z = 123;
  int *pz = &z;
  void *vpz;
  vpz = pz; //void указатель получает адрес из указателя pz.

  //Следует учитывать, что к void-указателю мы не можем применить операцию разыменования и тем самым получить значение по адресу, который хранится в этом указателе. Поэтому для получения
  //значения надо приводить к указателю соответствующего типа

  printf("Значение по указателю vpz %d \n", ((int *) vpz));

  //Адрес указателя
  //Указатель сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &

  int t = 400;
  int *pt = &t;

  printf("адрес указателя %p", &pt);

  //К указателям можно применять различные операции сравнения: >, >=, <, <=, == , !=. Используются для сравнения адресов
  return 0;
}