#include <stdio.h>

void func1(){
    auto int a; //int a
    a = 10;
}


void decrement(int *x){
    *x = *x - 1;
    printf("decrement: %d \n", *x);
}


void swap(int *a, int* b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

int triple(const int *x){
    //*x = *x - 1;
    int y = *x + *x + *x;
    return y;
}


void sub_2(size_t n, int p[]){
    for (size_t i = 0; i < n; i++){
        p[i] = p[i] - 2;
    }
}

void const_sub_2(size_t n, const int p[]){
    for (size_t i = 0; i < n; i++){
        //p[i] = p[i] - 2; так нельзя, так как const int
        printf("p[i] = %d \n", p[i]);
    }
}

typedef void (message1)(void);

void hello()
{
    printf("Hello \n");
}

void bye()
{
    printf("Bye \n");
}

int add(int a, int b)
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}

int mult(int a, int b)
{
    return a * b;
}

int ops(int (*op)(int, int), int a, int b){
    return op(a, b);
}
typedef int(sum_op)(int, int);
sum_op sum;

int isEven(int x)
{
    return x % 2 == 0;
}

int isNegative(int x)
{
    return x < 0;
}

void act(int (*condition) (int), int numbers[], size_t n)
{
    for(size_t i = 0; i < n; i++){
        if (condition(numbers[i]) != 0)
        {
            printf("%d \t", numbers[i]);
        }
    }
}

int (*select(int choice))(int, int)
{
    //тип_указателя_на функцию (*selece(параметры_функции))(параметры_указателя_на_функцию)
    switch (choice)
    {
        case 2:
            return sub;
        case 3:
            return mult;
        default:
            return add;
    }
}

int main(void){
    /*
    Классы хранения (Storage class) - модификатор, который определяет жизненный цикл и область видимости переменной или функции. Он сообщает компилятору, где и как хранить переменную,
    ее начальное значение по умолчанию, и кто к ней может обращаться.

    4 основных storage classes

    auto
    extern
    static
    register
    */
    /*
    Класс хранения auto является классом по умолчанию для всех локальных переменных. 

    Основные характеристики:
    1) Область видимости: локальная (все, связанное с переменной происходит исключительно в рамках того блока кода, которым она ограничена)
    2) Жизненный цикл: создается при входе в блок и уничтожается при выходе из него
    3) Начальное значение: если переменная не инициализирована явно, то она содержит неопределенное значение
    */

    /*
    extern - ключевое слово, которе используется для объявления глоабальной переменной или функции, которая определена в другом файле

    Основные характеристики:
    1) Область видимости: глобальная (доступна во всем проекте)
    2) Жизненный цикл: существует в течение всего времени выполнения программы
    3) Начальное значение: определяется в месте ее инициализации. Если глобальная переменная не определена явно, то она получается значение 0.
    */

    /*
    static - ключевое слово, которое имеет несколько видов применений в зависимости от контекста: для локальных переменных, для глобальных переменных/функций

    Локальные static-переменные:

    Основные характеристики:
    1) Область видимости: локальная
    2) Жизненный цикл: существует в течении всего времени выполнения программы
    3) Начальное значение: инициализируется только один раз при первом вызове функции. Если не определена явно, то получает значение 0

    Глобальные static-переменные.

    Основные характеристики:
    1) Область видимости: ограничена файлов, в котором она объявлена
    2) Жизненный цикл: существует в течении всего времени выполнения программы
    */

    /*
    register - класс хранения, который является некой рекомендация для компилятора поместить переменную не в оперативную память, а в регистр процессора. Доступ к регистрам быстрее,
    чем к памяти, поэтому это может оптимизировать производительность. Но современные компиляторы уже сами понимают, чему давать register, а чему не давать.

    Основные характеристики:
    1) Область видимости: локальная
    2) Жизненный цикл: локальный

    К переменной register я не могу применять & (операция взятия адреса), так как его просто нет.
    */
    register int i = 0;


    //Указатели и массивы как параметры функции
    int n = 20;
    decrement(&n); //теперь в функции decrement мы будем разыменовывать указатель, получать его значение и уменьшать на единицу.
    //поскольку функция принимает указатель, то при ее вызове надо передавать адрес переменной
    printf("main: %d \n", n); 


    int x = 10, y = 20;
    swap(&x, &y);
    printf("x = %d, y = %d \n", x, y);

    //Константные параметры. Если надо запретить менять значение параметра-указателя внутри функции, то можем определить такой параметр, как константый.
    int m = triple(&n);
    printf("n = %d, m = %d \n", n, m);

    //Массивы в параметрах. Если функция в качестве параметра принимает массив, то на самом деле в эту функцию передается только адрес начала массива. Как и в случае с указателями
    //нам доступен адрес, по которому можно менять значение.
    int nums[] = {2, 3, 4, 5, 6};
    size_t length = sizeof(nums) / sizeof(nums[0]);
    sub_2(length, nums);
    for (size_t i = 0; i < length; i++){
        printf("nums[i] = %d \n", nums[i]);
    }

    //Константный массив. В этом случае его не получится изменить внутри функции
    const_sub_2(length, nums);


    //Указатели на функции
    //Указатель на функцию содержит адрес первого байта, по которому располагается выполняемый код функции. Самым распространенным указателем на функцию является ее имя. 

    //Указатель на функцию можно определять в виде отдельной переменной
    //тип (*имя указателя) (типы параметров)

    void (*message) (void);
    message = hello; //указатель указывает на функцию hello
    message();
    message = bye;
    message();

    //при определении указателя стоит обратить внимание на скобки вокруг имени.
    //тип (*имя указателя) (типы параметров) не то же самое тип *имя указателя (типы параметров)


    int o = 10, u = 20;
    int result;

    //Следует внимательно следить за тем, чтобы указатель на функцию соотвествовал по типу возвращаемого значения и по типам параметро нужной функции
    int (*op)(int, int);
    op = add;
    result = op(o, u);
    printf("result = %d \n", result);

    op = sub;
    result = op(o, u);
    printf("result = %d \n", result);


    //Массивы указателей на функции
    //синтаксис: тип (*имя_массива[размер]) (параметры)

    int (*operations[2])(int, int) = {add, sub};
    size_t length1 = sizeof(operations) / sizeof(operations[0]);
    for(size_t i = 0; i < length1; ++i){
        printf("operations[i] = %d \n", operations[i](o, u));
    }

    //Тип функции. Используя определение функции (ее возвращаемый тип, типы параметров), мы можем описать тип функций. Для этого применяется typedef

    //typedef возвращаемый_тип (название)(типы_параметров);
    //Определение типа функции упрощает применение указателей на функции.

    message1* mes1= &hello; //указатель, который указывает на функцию hello
    message1* mes2 = &bye;

    mes1();
    mes2();

    sum_op* op1 = &sum;
    printf("result = %d \n", op1(10, 5));


    //Массивы функций
    sum_op* opers[] = {&sum, &add, &sub};
    printf("result = %d \n", opers[0](10, 5));
    printf("result = %d \n", opers[1](10, 5));
    printf("result = %d \n", opers[2](10, 5));
    
    //Функции как параметры других функции

    result = ops(add, o, u);
    printf("result = %d \n", result);


    int numbers[] = {4, 3, 2, -1, 0, -8, -9, 2, 3};
    size_t n1 = sizeof(numbers) / sizeof(numbers[0]);
    printf("Even numbers: ");
    act(isEven, numbers, n1);
    printf("\nNegative numbers:");
    act(isNegative, numbers, n1);

    //Функция как результат другой функции
    int (*operates)(int, int); // указатель на выбранную функцию
    operates = select(1);
    int result1 = operates(6, 10);
    printf("result1 = %d \n", result1);
    return 0;
}

int sum(int x, int y) {return x + y;}