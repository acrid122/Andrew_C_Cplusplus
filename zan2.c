#include <stdio.h>
#include <locale.h>
int main(void){
    setlocale(LC_ALL, "ru_RU.UTF-8");
    /*
    printf(строка форматирования, список аргументов)
    */
    printf("Hello world!");

    /*
    \n - переход на новую строку
    \t - табуляция
    \r - возврат картеки (курсор) в начало строки
    \ - служит для экранирования символов:
    \" - двойная кавычка
    \' - одинарная кавычка
    \\ - обратный слэш
    */
    printf("\"Привет\",- сказал он \n");
    // %флаг ширина_поля.точность модификатор спецификатор
    /*
    Спецификаторы
    %c - для вывода отдельных символов
    %s - для вывода
    %d - для вывода целых чисел со знаком (decimal), %i
    %u - для вывода целых положительных чисел (unsigned int)
    %f - для вывода чисел с плавающей точкой
    %e - для вывода экспоненциального представления чисел с плавающей точкой
    %o - для вывода восьмиричных чисел без знака
    %x - для вывода шестнадцатеричных чисел
    %% - для вывода знака процента
    */
    char symbol = 'r';
    printf("symbol = %c \n", symbol);
    float r = 35.3637;
    printf("y = %f \n", r);
    printf("y = %e \n", r);
    //25e-3 = 0.025
    printf("y = %4.2f \n", r);
    printf("y = %.3f \n", r);
    printf("y = %7.2f \n", r);

    /*
    Модификаторы
    h - для вывода значений short int
    l - для вывода значений long int и unsigned long int
    ll - для вывода значений long long int и unsigned long long int
    L - для вывода значений long double
    */
    short b = 2000;
    printf("y = %hd \n", b);
    printf("y = %d \n", b);

    printf("Имя: %s \t Возраст: %d \t Вес: %.3f \n", "Вася", 23, 65.7879);

    /*
    Флаги:
    -n: выравнивание идет от левого края
    +: если выводимое значение имеет знак (+ или -), то оно выводится. без данного флага - знак только у отрицательных
    ' ' (пробел): вставляет пробел на месте знака с положительными числами
    #: при работы со спецификаторами "o", "x" будет выводить значения числа с предшествующими символами 0, 0x. При использовании со спецификаторами "f", "g" десятичная точка
    будет выводиться, даже если в числе нет дробной части  
    */
    printf("%d \n", 10);
    printf("% d \n", 10);
    printf("%+d \n", 10);
    printf("%#o \n", 10);
    printf("%#f \n", 10.);

    printf("%-15s %d \n", "Вася", 23);
    printf("%15s %d \n", "Вася", 23);

    int number = 10;
    printf("%d \n", number);
    number = 20;
    printf("%d \n", number);

    const int number_1 = 10;
    printf("%d \n", number_1);
    //expression must be a modifiable lvalue
    //number_1 = 20; эта строка работать не будет, так как number_1 - это константа
    printf("%d \n", number_1);

    /*
    + - сложение чисел
    - - вычитание чисел
    * - умножение чисел
    / - деление чисел
    % - остаток от деления
    */
    int a1 = 10, b1 = 20, c1 = 30;
    printf("Сумма: a + b + c = %d \n", a1 + b1 + c1);
    printf("Разность: a - b - c = %d \n", a1 - b1 - c1);
    printf("Умножение: a * b * c = %d \n", a1 * b1 * c1);

    int a2 = 15 / 3;
    printf("a2 = %d \n", a2);

    float a3 = 34.0 / 3.0;
    printf("a3 = %f \n", a3);

    float a4 = 35 / 3; // в данном случае произошло округление (целочисленное деление)
    printf("a4 = %d \n", a4);

    int a5 = 40 % 6;
    printf("a5 = %d \n", a5);

    // унарные операции - операция над одним числом (-7, +8): ++ (инкремент), -- (декремент). Каждая из этих операция имеет 2 вида: префиксный и постфиксный.

    //префиксная ++x, постфиксная x++.

    /*
    В префиксной форме сначала изменяется значение переменной, затем возвращается новое значение.
    Если x = 5, то ++x сначала делает x = 6, а затем возвращает 6

    В постфиксной форме сначала возвращается текущее значение переменной, а затем оно изменяется.
    x = 5, то x++ верней 5, а затем сделает 6
    */

    int x = 5, y;
    
    //Префиксная форма
    y = ++x;
    printf("Префикс: x = %d, y = %d\n", x, y);

    x = 5;

    //Постфиксная форма
    y = x++;
    printf("Постфикс: x = %d, y = %d\n", x, y);

    x = 5;
    y = 5;

    int c = x+++y; //(x++) + y
    printf("c = %d\n", c);

    x = 5;

    c = ++x + y;
    printf("c = %d\n", c);

    /*
    Операции отношения
    == - операция равно
    != - операция не равно
    > - больше
    < - меньше
    >= - больше или равно
    <= - меньше или равно
    */
    printf("result = %d\n", 5 == 5);
    printf("result = %d\n", 5 == 6);
    printf("result = %d\n", 5 != 5);
    printf("result = %d\n", 5 != 6);
    printf("result = %d\n", 5 > 5);
    printf("result = %d\n", 5 < 6);
    printf("result = %d\n", 5 >= 5);
    printf("result = %d\n", 5 <= 6);

    /*
    Логические операции
    ! - логическое отрицание (НЕ), инверсия
    && - логическое умножение (И), конъюнкция
    || - логическое сложение (ИЛИ), дизъюнкция

    0 - False, ложь. !0 - 1, истина
    1 - True, истина. !1 - 0, ложь

    Операции сравнения имеют больший приоритет, чем логические операции.
    */
    printf("result = %d\n", !(5 == 6));
    printf("result = %d\n", 0 && 1);
    /*
    a and b = f
    0 and 0 = 0
    1 and 0 = 0
    0 and 1 = 0
    1 and 1 = 1
    */
    printf("result = %d\n", 0 || 1);
    /*
    a or b = f
    0 or 0 = 0
    1 or 0 = 1
    0 or 1 = 1
    1 or 1 = 1
    */

    //Поразрядные операции

    /*
    Операции сдвига (работают с числами в их двоичном представлении). Применяются только к целочисленным операндам
    << - сдвиг влево
    >> - сдвиг вправо

    2_10 = 10_2
    */
   int a6 = 2 << 2; //число 2 в двоичном представлении сдвигаем на 2 разряда влево. на место новых разрядов ставятся нули. 10_2 -> 1000_2 = 8
   int a7 = 2 >> 1; //число 2 в двоичном представлении сдвигается на 1 разряд вправо. тот разряд, на который происходит сдвиг, удаляется. 10_2 -> 1_2 = 1.
   printf("a6 = %d, a7 = %d\n", a6, a7);

   /*
   & - поразрядная конъюнкция. Операция И побитовая.

   4_10 = 100_2
   5_10 = 101_2

   4 & 5 = 100_2

   | - поразрядная дизъюнкция. Операция ИЛИ побитовая.

   4_10 = 100_2
   5_10 = 101_2

   4 | 5 = 101_2

   ^ - поразрядное исключающее или. Операция XOR побитовая.

   4_10 = 100_2
   5_10 = 101_2

   4 ^ 5 = 001_2

   Представление отрицательных числел. Для записи чисел со знаком применяется дополнительный код, при котором старший разряд является знаковым. Если его значение равно 0, то
   число положительное, и его двоичное представление не отличается от представления беззнакого числа. Например, 00001 = 1.

   Если старший разряд равен 1, то это отрицательное числоа. Например,


   Чтобы получить из положительного числа отрицательное, то его нужно инвертировать и прибавить единицу (дополнительный код).
   5_10 = 00000000 00000000 00000000 00000101_2 (так выглядит по факту, так как int занимает 32 бита)
   ~00000000 00000000 00000000 00000101_2 -> 11111111 11111111 11111111 11111010_2
   00000000 00000000 00000000 00000101_2 + 1 -> 00000110 = 6. -> -6
   1010_2 - после инверсии


   ~ - поразрядное отрицание. Инвертирует все разряды операнда.
   5_10 = 101_2

   ~5 = 010_2
   */

   int a8 = 4 & 5;
   int a9 = 4 | 5;
   int a10 = 4 ^ 5;
   int a11 = ~5;
   printf("a8 = %d, a9 = %d, a10 = %d, a11  = %d\n", a8, a9, a10, a11);
}

