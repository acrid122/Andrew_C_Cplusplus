#include <iostream>

int main(void){
    /*
    1 вопрос:
    Тип данных - это характеристика, определеяющая
    -диапазон допустимых значений,
    -способ представления в памяти,
    -допустимые операции над этими данными

    Числовые типы данных - типы данных, предназначенные для хранения числовый значений и выполнения арифметический вычислений. int, double, float, unsigned int, long, long long.

    Целочисленный тип данных - тип данных, предназначенный для хранения целых чисел без дробной части. Может быть либо знаковым, либо беззнаковым.

    Вещественный тип данных - тип данных, предназначенный для хранения чисел с дробной частью.

    Числовой литерал - именованная область памяти, предназначенная для хранения значения определенного типа. 10 - целый десятичный, 012 - восьмиричный, 0xFF - шестнадцатеричный, 3.14 double,
    3.14f - float, 10U - unsigned. Числовые литералы не изменяются в ходе выполнения программы.

    Переменная - именованная область памяти, предназначенная для хранения значения определенного типа данных.

    Инициализация - присваивание переменной начального значения в момент ее объявления. 
    int x = 5;
    double y = 2.5;

    Операция присваивания - операция записи значения в переменную с помощью =.
    Составная операция присваивания - операция, которая объединяет аримфметическую операцию и присваивание. Например, +=, -= ...

    Особенности:
    размеры типов зависят от архитектуры и компилятора
    переполнение знаковых чисел приводит к неопределенному поведению
    вещественные числа хранятся приблеженно и могут иметь погрешность.
    по умолчанию вещественные литералы имеют тип double.

    Применение:
    int - универсальный тип для большинства задач
    unsigned - работа с битами, флагами, размерами
    double - вычисления с дробной частью
    float - экономия памяти при больших массивах чисел
    */

    /*
    2 вопрос:
    Тип данных - это характеристика, определеяющая
    -диапазон допустимых значений,
    -способ представления в памяти,
    -допустимые операции над этими данными
    
    Целочисленный тип данных - тип данных, предназначенный для хранения целых чисел без дробной части. Может быть либо знаковым, либо беззнаковым.

    В языке С целочисленные данные представлены следующими типами:
    char, short int, int, long int, long long int

    Каждый целочисленный тип может быть
    знаковым (signed) - допускает отрицательные значения
    беззнаковым (unsigned) - допускает только неорицательные значения

    Логическое (двоичное) представление данных в памяти - это способ хранения чисел в виде последовательности битов (0 и 1). Целые числа в памяти хранятся в двоичной системе счисления.

    Пример двоичного представления:

    10_10 = 00001010_2

    Для знаковых типов:
    старший бит - знаковый (0- положительное, 1 - отрицательное)

    Дополнительный код - это способ представления отрицательных целых чисел в памяти, при котором:
    1. берется двоичное представление положительного числа.
    2. инвертируются все биты
    3. к результату прибавляется 1.

    Пример представления отрицательного числа: -5, то (показываем 8-битную)
    5 = 00000101
    ~5 = 11111010
    -5 = 11111011 (инверсия + 1)

    Этот способ используется в большинстве архитектур.

    Пример из zan2.c

    Представление отрицательных числел. Для записи чисел со знаком применяется дополнительный код, при котором старший разряд является знаковым. Если его значение равно 0, то
   число положительное, и его двоичное представление не отличается от представления беззнакого числа. Например, 00001 = 1.

   Если старший разряд равен 1, то это отрицательное числоа. Например,


   Чтобы получить из положительного числа отрицательное, то его нужно инвертировать и прибавить единицу (дополнительный код).
   5_10 = 00000000 00000000 00000000 00000101_2 (так выглядит по факту, так как int занимает 32 бита)
   ~00000000 00000000 00000000 00000101_2 -> 11111111 11111111 11111111 11111010_2
   00000000 00000000 00000000 00000101_2 + 1 -> 00000110 = 6. -> -6
   1010_2 - после инверсии


   ~ - поразрядное отрицание. Инвертирует все разряды операнда.
   5_10 = 101_2

   ~5 = 010_2

    Операции над целочисленными величинами:

    + - сложение
    - - вычитание
    * - умножение
    / - целочисленное деление
    % - остаток от деления

    Операции срванения

    ==, !=, <, >, <=, >=

    Побитовые операции

    Побитовое И (&)

    Операция AND (&) устанавливает бит в 1, если соответствующие биты обоих операндов равны 1
    6 & 8 = 0110_2 & 1000_2 = 0
    Операция OR (|) устанавливает бит в 1, если хотя бы один из битов равен 1
    6 | 8 = 0110_2 | 1000_2 = 1110_2 = 14
    Побитовое исключающее ИЛИ/XOR (^) устанавливает бит в 1, если биты операндов различны.
    6 ^ 8 = 0110_2 ^ 1000_2 = 1110_2 = 14
    Побитовое НЕ (~) инвертирует все биты числа.
    ~6 = 1001_2 = 9

    Операции сдвига:

    Оператор << (сдвиг влево). Сдвигает биты числа влево, освобождающие младшие биты заполняются нулями.

    unsigned int x = 5; //101
    x << 2; //10100

    Часто эквивалентно умножению на 2^n (если нет переполнения)

    Оператор >> (сдвиг вправо).

    Оператор >> сдвигает биты числа вправо.
    unsigned int x = 5; //101
    x >> 2; //1
    для unsigned - старшие биты заполняются нулями, для signed - поведение зависит от реализации (часто заполнятся знаковым битом)
    */
   /*
    3. 
    Условная алгоритмическая конструкция - это конструкция алгоритма, обеспечивающая выбор одного из возможных путей выполнения программы в зависимости от истинности логического условия.

    Условие - логическое выражение, результатом которого является истина или ложь.

    В языке C:

    значение 0 интерпретируется как ложь,

    любое ненулевое значение интерпретируется как истина.

    Логическое выражение - выражение, результатом вычисления которого является целое значение, используемое как логическое (истина или ложь).

    x > 0
    a == b
    n % 2 == 0

    Оператор if - это оператор условного выполнения, который позволяет выполнить определённый блок кода только в том случае, если заданное условие истинно.

    Сокращённая форма оператора if - форма условного оператора, в которой отсутствует ветвь else.

    if (условие)
    оператор;

    int x = 5;

    if (x > 0)
        printf("x is positive\n");

    В этом случае оператор printf выполнится только при выполнении условия x > 0.

    Полная форма оператора if - форма условного оператора, в которой присутствует альтернативная ветвь else.

    if (условие)
        оператор1;
    else
        оператор2;

    int x = -3;

    if (x > 0)
        printf("positive\n");
    else
        printf("not positive\n");

    Составной оператор - это группа операторов, заключённых в фигурные скобки { }, рассматриваемая как один оператор.

    if (x > 0) {
        printf("x is positive\n");
        printf("x = %d\n", x);
    } else {
        printf("x is not positive\n");
    }

    Выбор более чем из двух альтернатив - это реализация многоальтернативного ветвления с использованием цепочки операторов if - else if - else.

    if (условие1)
        оператор1;
    else if (условие2)
        оператор2;
    else if (условие3)
        оператор3;
    else
        оператор4;

    int score = 75;

    if (score >= 90)
        printf("Grade A\n");
    else if (score >= 75)
        printf("Grade B\n");
    else if (score >= 60)
        printf("Grade C\n");
    else
        printf("Grade F\n");

    Вложенный оператор if - оператор if, расположенный внутри другого оператора if или else.  

    if (x >= 0) {
        if (x == 0)
            printf("zero\n");
        else
            printf("positive\n");
    } else {
        printf("negative\n");
    }
    Особенности:
    Условие всегда заключается в круглые скобки.

    В языке C отсутствует логический тип в классическом виде (в стандартном C89/C90), используется целочисленная логика.

    Оператор if не возвращает значение.

    Без фигурных скобок к if относится только один следующий оператор.
   */

    /*
    4 вопрос:

    Выражение - это синтаксическая конструкция языка C, состоящая из операндов и операторов, которая вычисляется в некоторое значение и может иметь тип данных.
    Результат выражения может быть:

    числовым,

    логическим,

    символьным,

    указательным.


    Операнд - объект, над которым выполняется операция (переменная, константа, результат другого выражения).

    Оператор - элемент языка, определяющий действие, выполняемое над операндами.


    Тернарный оператор — оператор, принимающий три операнда.

    В языке C существует только один тернарный оператор - условный оператор ?:.


    Тернарная условная операция ?: - выражение, которое в зависимости от истинности условия вычисляет и возвращает одно из двух значений.

    условие ? выражение1 : выражение2

    если условие истинно — вычисляется выражение1,

    если ложно — вычисляется выражение2.

    int a = 10, b = 20;
    int max = (a > b) ? a : b;

    Эквивалентный код

    int max;
    if (a > b)
        max = a;
    else
        max = b;

    ?: — выражение, возвращающее значение,

    if — оператор управления, не возвращающий значение.

    Общие свойства

    Используют логическое условие.

    Реализуют выбор одного из альтернативных путей выполнения.

    Основаны на интерпретации условия как истинного или ложного.

    | Критерий                             | Тернарный оператор `?:` | Оператор `if` |
    | ------------------------------------ | ----------------------- | ------------- |
    | Категория                            | Выражение               | Оператор      |
    | Возвращает значение                  | Да                      | Нет           |
    | Можно использовать внутри выражений  | Да                      | Нет           |
    | Может содержать несколько операторов | Нет                     | Да            |
    | Подходит для сложной логики          | Нет                     | Да            |

    printf("%d\n", (x > 0) ? 1 : -1);

    Эквивалент с if невозможен без временной переменной.

    Тернарный оператор имеет низкий приоритет.

    Ассоциативность — справа налево.

    int x = a ? b : c ? d : e;

    int x = a ? b : (c ? d : e);

    Другие операторы, образующие выражения
    Арифметические операторы, Операторы сравнения, Логические операторы, Побитовые операторы, Операторы присваивания, Инкремент и декремент.
    */

    /*
    5 вопрос.
    
    Циклическая алгоритмическая конструкция - это конструкция алгоритма, обеспечивающая многократное выполнение одного и того же блока кода до тех пор, пока выполняется заданное условие.

    Итерация - это одно повторение тела цикла.

    Оператор цикла - оператор языка программирования, предназначенный для организации циклического выполнения кода.

    Оператор for - это цикл с заранее заданной схемой управления, включающей инициализацию, условие продолжения и шаг изменения параметра цикла.

    Управляющий блок оператора for - часть оператора for, заключённая в круглые скобки, которая определяет порядок выполнения цикла.

    for (инициализация; условие; шаг) {
        тело цикла;
    }

    Инициализация - выполняется один раз перед началом цикла.

    Условие - проверяется перед каждой итерацией.

    Шаг - выполняется после каждой итерации.

    for (int i = 0; i < 5; i++) {
        printf("%d ", i);
    }

    Параметр цикла (счётчик) - переменная, которая управляет числом повторений цикла и изменяется по заданному правилу на каждой итерации.

    for (int i = 1; i <= 10; i++) {
        printf("%d ", i);
    }

    Здесь:

    i - параметр цикла,

    начальное значение 1,

    шаг изменения +1,

    условие завершения i <= 10.

    Вложенный цикл - это цикл, тело которого содержит другой цикл.

    for (int i = 1; i <= 3; i++) {
        for (int j = 1; j <= 3; j++) {
            printf("(%d,%d) ", i, j);
        }
        printf("\n");
    }

    Внешний цикл выполняется 3 раза, внутренний - 3 раза для каждой итерации внешнего.

    Оператор break - оператор управления, который немедленно завершает выполнение ближайшего цикла.

    for (int i = 1; i <= 10; i++) {
        if (i == 5)
            break;
        printf("%d ", i);
    }

    Оператор continue - оператор управления, который завершает текущую итерацию цикла и переходит к следующей.

    for (int i = 1; i <= 5; i++) {
        if (i == 3)
            continue;
        printf("%d ", i);
    }

    Особенность:

    Все части управляющего блока являются необязательными.
    for (;;) {
        // бесконечный цикл
    }

    Внутри цикла можно изменять параметр цикла вручную.

    Переменная, объявленная в for, имеет область видимости тела цикла.
    */

    /*
    6 вопрос.

    Циклическая алгоритмическая конструкция - это конструкция алгоритма, обеспечивающая многократное выполнение одного и того же блока кода до тех пор, пока выполняется заданное условие.

    Итерация - это одно повторение тела цикла.

    Оператор цикла - оператор языка программирования, предназначенный для организации циклического выполнения кода.

    Оператор while - оператор цикла с проверкой условия перед выполнением тела цикла.

    Оператор do-while - оператор цикла с проверкой условия после выполнения тела цикла, гарантирующий выполнение тела хотя бы один раз.

    Условие цикла - логическое выражение, определяющее необходимость продолжения выполнения цикла.

    Синтаксис while
    while (условие) {
        тело цикла;
    }

    Проверяется условие.

    Если условие истинно - выполняется тело цикла.

    После выполнения тела снова проверяется условие.

    Если условие ложно изначально, тело цикла не выполняется ни разу.
    int i = 1;

    while (i <= 5) {
        printf("%d ", i);
        i++;
    }

    Целесообразность применения:

    Цикл while используется, когда:

    количество повторений заранее неизвестно,

    возможно, что цикл не выполнится ни разу,

    условие определяется в процессе работы программы.

    do {
        тело цикла;
    } while (условие);

    Обязательно ставится точка с запятой после while.

    Сначала выполняется тело цикла.

    Затем проверяется условие.

    Если условие истинно — цикл повторяется.

    Тело цикла выполняется как минимум один раз.

    int x;

    do {
        printf("Enter positive number: ");
        scanf("%d", &x);
    } while (x <= 0);

    Целесообразность применения:

    Цикл do-while используется, когда:

    необходимо гарантировать хотя бы одно выполнение тела цикла,

    требуется организовать ввод данных с проверкой,

    реализуется меню или диалог с пользователем.

    | Характеристика   | while         | do-while         |
    | ---------------- | ------------- | ---------------- |
    | Проверка условия | до выполнения | после выполнения |
    | Минимум итераций | 0             | 1                |
    | Использование    | универсальное | ввод, меню       |

    Оператор break немедленно завершает выполнение ближайшего цикла независимо от условия.

   int i = 1;

    while (i <= 10) {
        if (i == 5)
            break;
        printf("%d ", i);
        i++;
    }
 
    Оператор continue завершает текущую итерацию цикла и передаёт управление на следующую итерацию.

    int i = 0;

    while (i < 5) {
        i++;
        if (i == 3)
            continue;
        printf("%d ", i);
    }
    
    Типичные ошибки при использовании циклов

    Забытый инкремент переменной цикла - бесконечный цикл.

    Отсутствие точки с запятой в do-while.

    Использование continue без изменения управляющей переменной.
    */

    /*
    7 вопрос.

    Исходный файл - файл с расширением .c, содержащий реализацию функций, операторов и алгоритмов программы.


    Заголовочный файл - файл с расширением .h, содержащий объявления функций, типов данных, констант и макросов, которые используются в других исходных файлах.

    Заголовочные файлы не содержат реализацию функций, а только их объявления.


    Объявление - сообщение компилятору о существовании функции, переменной или типа без описания их реализации.

    Реализация (определение) - описание того, как функция или объект работает и что она делает.

    Модуль программы - логически законченная часть программы, обычно представленная парой файлов: .h и .c.


    Роль заголовочных файлов

    обеспечивают доступ к объявлениям функций и типов,

    позволяют разделять программу на модули,

    упрощают сопровождение и повторное использование кода.


    Роль исходных файлов

    содержат реализацию функций,

    компилируются в объектные файлы,

    объединяются на этапе компоновки.

    Заголовочный файл mathutil.h

    #ifndef MATHUTIL_H
    #define MATHUTIL_H

    int add(int a, int b);
    int sub(int a, int b);

    #endif

    Исходный файл mathutil.c

    #include "mathutil.h"

    int add(int a, int b) {
        return a + b;
    }

    int sub(int a, int b) {
        return a - b;
    }

    Главный файл main.c

    #include <stdio.h>
    #include "mathutil.h"

    int main(void) {
        printf("%d\n", add(5, 3));
        return 0;
    }

    Построение выполняемой программы - процесс преобразования исходного кода на языке C в исполняемый файл.

    Этап 1. Препроцессирование

    Препроцессирование — этап, на котором:

    обрабатываются директивы #include,

    разворачиваются макросы #define,

    выполняется условная компиляция.

    Результат - исходный код без директив препроцессора.

    Этап 2. Компиляция

    Компиляция - преобразование препроцессированного кода в объектный код.

    На этом этапе:

    проверяется синтаксис,

    проверяются типы,

    формируется объектный файл (.o или .obj).

    Этап 3. Ассемблирование

    Ассемблирование - преобразование ассемблерного кода в машинный код (обычно включено в этап компиляции).

    Этап 4. Компоновка (линковка)

    Компоновка (linking) - объединение объектных файлов и библиотек в один исполняемый файл.

    На этом этапе:

    связываются вызовы функций,

    разрешаются внешние ссылки,

    формируется исполняемый файл.

    Схема этапов:
    .c - препроцессор - компилятор - объектные файлы - линковщик - .exe / a.out

    Точка входа программы - это функция, с которой начинается выполнение программы после её запуска.

    В языке C точкой входа является функция main.

    int main(void), int main(int argc, char *argv[])

    argc — количество аргументов командной строки,

    argv — массив строк с аргументами командной строки.

    Функция main возвращает целое число:

    0 — успешное завершение программы,

    ненулевое значение — ошибка.

    int main(void) {
        return 0;
    }

    Особенности:

    Заголовочные файлы подключаются с помощью #include.

    Один заголовочный файл может использоваться в нескольких исходных файлах.

    Каждая программа должна содержать ровно одну функцию main.

    Отсутствие main приводит к ошибке компоновки.
    */

    /*
    8 вопрос.

    Препроцессор - это этап обработки программы, выполняемый до компиляции, который анализирует и обрабатывает специальные директивы, начинающиеся с символа #.

    Препроцессор не понимает синтаксис языка C, а выполняет текстовые преобразования.

    Инструкция препроцессора - специальная команда, начинающаяся с #, которая управляет обработкой исходного кода до компиляции.

    Заголовочный файл - файл с расширением .h, содержащий объявления функций, типов данных, констант и макросов, предназначенных для использования в нескольких исходных файлах.

    
    Макрос - правило текстовой подстановки, определяемое с помощью директивы #define.

    Макрозащита - механизм предотвращения многократного включения одного и того же заголовочного файла в программу.

    Основные инструкции препроцессора

    #include

    Директива #include используется для включения содержимого другого файла в текущий файл.

    #include <stdio.h>   // системный заголовочный файл
    #include "my.h"      // пользовательский заголовочный файл

    < > — поиск в системных каталогах,

    " " — сначала поиск в текущем каталоге.

    #define

    Директива #define используется для определения макросов.

    #undef

    Директива #undef удаляет ранее определённый макрос.

    #define A 10
    #undef A

    Назначение заголовочных файлов

    объявление функций,

    объявление типов данных,

    объявление констант и макросов,

    обеспечение модульности программы.

    // mathutil.h
    int add(int a, int b);

    Использование в исходном файле

    #include "mathutil.h"

    int add(int a, int b) {
        return a + b;
    }

    Макрозащита (защита от повторного подключения)

    Макрозащита предотвращает повторное включение одного и того же заголовочного файла, которое может привести к ошибкам повторного объявления.

    #ifndef MY_HEADER_H
    #define MY_HEADER_H

    // содержимое заголовочного файла

    #endif

    При первом включении макрос не определён - файл подключается.

    Макрос определяется.

    При повторном включении файл игнорируется.

    Объектоподобные макросы

    Объектоподобный макрос - макрос без параметров, заменяющий идентификатор на текст.

    #define PI 3.1415926

    double r = PI * 2;

    Функциональный макрос - макрос с параметрами, выполняющий текстовую подстановку.

    #define SQR(x) ((x) * (x))

    int a = SQR(5);     // 25
    int b = SQR(2 + 3); // корректно из-за скобок

    Особенности макросов

    макросы не проверяют типы,

    макросы не являются функциями,

    | Макрос                | Функция                   |
    | --------------------- | ------------------------- |
    | Текстовая подстановка | Вызов во время выполнения |
    | Нет проверки типов    | Есть проверка типов       |
    | Может быть быстрее    | Может быть безопаснее     |
    | Может быть опасен     | Предсказуемое поведение   |
    */

    /*
    9 вопрос.

    Тип данных — характеристика данных, определяющая:

    способ хранения в памяти,

    диапазон допустимых значений,

    допустимые операции.


    Встроенные типы данных - типы, изначально определённые стандартом языка C и не требующие объявления пользователем.

    Типы данных, объявленные пользователем - типы, создаваемые программистом для описания собственных структур данных.

    Объявление типа - синтаксическая конструкция, определяющая имя типа и его структуру.

    typedef - оператор языка C, предназначенный для создания псевдонима (альтернативного имени) для существующего типа.

    sizeof - оператор языка C, возвращающий размер объекта или типа данных в байтах.

    Встроенные типы данных в языке C:

    Целочисленные типы:

    char
    short int
    int
    long int
    long long int

    Каждый из них может быть:

    signed

    unsigned

    Вещественные типы

    float
    double
    long double

    Пример использования:

    int a = 10;
    double b = 3.14;
    unsigned long n = 1000;

    Типы данных, объявленные пользователем:

    Структуры (struct)

    Структура - тип данных, объединяющий несколько переменных различных типов под одним именем.

    struct Point {
        int x;
        int y;
    };

    struct Point p = {1, 2};

    Перечисления (enum)

    Перечисление - тип данных, представляющий набор именованных целочисленных констант.

    enum Color {
        RED, GREEN, BLUE
    };

    Объединения (union)

    Объединение - тип данных, позволяющий хранить в одной области памяти разные типы данных, но только одно значение одновременно.

    union Data {
        int i;
        float f;
    };

    typedef используется для создания нового имени для существующего типа данных.

    typedef unsigned long long ull;

    ull x = 100;

    typedef struct {
        int x;
        int y;
    } Point;

    Point p1;

    Преимущества typedef

    повышает читаемость кода,

    упрощает сложные объявления,

    облегчает переносимость программ.


    Чтение объявления в C начинается с имени переменной, затем анализируется вправо и влево с учётом приоритета операторов.

    int *p;

    p - указатель на int.

    int a[10];

    a - массив из 10 элементов типа int.

    int *a[10];

    a - массив из 10 указателей на int.

    int (*p)[10];

    p - указатель на массив из 10 int.

    int (*f)(int);

    f - указатель на функцию, принимающую int и возвращающую int.

    sizeof определяет размер объекта или типа данных в байтах на конкретной платформе.

    sizeof(тип)
    sizeof(выражение)

    printf("%zu\n", sizeof(int));
    printf("%zu\n", sizeof(double));

    int a[10];
    printf("%zu\n", sizeof(a));      // размер массива
    printf("%zu\n", sizeof(a[0]));   // размер одного элемента

    Тип возвращаемого значения

    sizeof возвращает значение типа size_t.
    */

    /*
    10 вопрос.
    Массив - это структура данных, представляющая собой упорядоченный набор элементов одного типа, размещённых в памяти непрерывно и доступных по индексу.

    Элемент массива - отдельное значение массива, доступ к которому осуществляется по индексу.

    Индекс массива - целое число, указывающее позицию элемента в массиве. В языке C индексация начинается с 0.

    Размер массива - количество элементов, которое может содержать массив. Размер задаётся при объявлении и не может изменяться во время выполнения программы.

    Тип char - целочисленный тип данных, предназначенный для хранения символов и их кодов

    Z-строка - это массив символов типа char, заканчивающийся нулевым символом '\0', который обозначает конец строки.

    Объявление массива

    int a[5];

    Здесь:

    a - имя массива,

    5 - количество элементов,

    int - тип элементов.

    Объявление с инициализацией

    int a[5] = {1, 2, 3, 4, 5};

    Частичная инициализация

    int b[5] = {1, 2};

    Эквивалентно:
    int b[5] = {1, 2, 0, 0, 0};

    Автоматическое определение размера
    
    int c[] = {10, 20, 30};

    Размер массива определяется числом элементов инициализации.

    Основные свойства массивов

    Все элементы массива имеют один и тот же тип.

    Элементы хранятся в непрерывной области памяти.

    Доступ к элементам осуществляется за O(1).

    Размер массива фиксирован после объявления.

    Индексы допустимы в диапазоне 0 ... size-1.

    Доступ к элементам массива

    a[0] = 10;
    a[4] = 20;

    a[5] = 100;  // ошибка: выход за границы массива

    Размер массива

    int a[10];
    int size = sizeof(a) / sizeof(a[0]);

    Работает только в том месте, где массив объявлен как массив, а не передан в функцию.

    Массивы и указатели (важное свойство)

    Имя массива в выражениях преобразуется в указатель на первый элемент.

    int a[5];
    int *p = a;      // p указывает на a[0]

    a[i] == *(a + i)

    char - целочисленный тип данных, обычно занимающий 1 байт, предназначенный для хранения символов.

    char c = 'A';
    char d = '\n';

    Фактически в char хранится код символа (ASCII и т.п.).

    Z-строка - это массив символов char, оканчивающийся нулевым символом '\0'.

    char s[] = "Hello";

    'H' 'e' 'l' 'l' 'o' '\0'

    char s[] = {'H','e','l','l','o','\0'};

    char s[10] = "Hi";

    'H' 'i' '\0' 0 0 0 0 0 0 0

    printf("%s\n", s);

    Работа со строками

    Длина строки

    #include <string.h>

    int len = strlen(s); // не учитывает '\0'

    Копирование строк

    strcpy(dest, src);

    Требует, чтобы dest был достаточно большого размера.

    Сравнение строк

    strcmp(s1, s2);

    Типичные ошибки при работе со строками

    Недостаточный размер массива:

    char s[5] = "Hello"; // ошибка: нужно 6

    Отсутствие '\0':

    char s[] = {'H','i'}; // не строка!

    | Массив `char`         | Z-строка                   |
    | --------------------- | -------------------------- |
    | Может не иметь `'\0'` | Всегда оканчивается `'\0'` |
    | Просто массив         | Строка языка C             |
    | `%c`                  | `%s`                       |

    */
    /*
    18 вопрос.

    Структура - это пользовательский тип данных языка C, который позволяет объединять несколько переменных разных типов под одним именем.

    Поле структуры - отдельный элемент структуры, имеющий имя и тип данных.

    Экземпляр структуры - конкретная переменная структурного типа, в которой хранятся значения всех полей структуры.

    Указатель на структуру - переменная, содержащая адрес структуры в памяти.

    Оператор доступа к полю

    . - доступ к полю структуры через объект структуры

    -> - доступ к полю структуры через указатель

    Структуры используются для:

    логического объединения связанных данных,

    моделирования реальных объектов (точка, студент, запись),

    удобной передачи группы данных в функции,

    построения сложных структур данных (списки, деревья, графы).

    Объявление структурного типа:

    struct Point {
        int x;
        int y;
    };

    Здесь:

    struct Point — имя структурного типа,

    x, y — поля структуры.

    Объявление переменной структуры:

    struct Point p;

    Объявление с инициализацией:

    p.x = 10;
    p.y = 20;

    Доступ к полям структуры:

    p.x = 10;
    p.y = 20;

    #include <stdio.h>

    struct Point {
        int x;
        int y;
    };

    int main(void) {
        struct Point p;
        p.x = 5;
        p.y = 7;

        printf("x = %d, y = %d\n", p.x, p.y);
        return 0;
    }

    Полная инициализация:

    struct Point a = {1, 2};

    Частичная инициализация:

    struct Point b = {5}; // b.x = 5, b.y = 0

    Указатель на структуру

    struct Point p = {3, 4};
    struct Point *ptr = &p;

    Доступ к полям через указатель:

    Через разыменование:

    (*ptr).x = 10;

    Через оператор ->:

    ptr->y = 20;

    Оператор -> является сокращённой формой записи (*ptr).field.

    #include <stdio.h>

    struct Point {
        int x;
        int y;
    };

    int main(void) {
        struct Point p = {1, 2};
        struct Point *ptr = &p;

        ptr->x = 10;
        ptr->y = 20;

        printf("%d %d\n", p.x, p.y);
        return 0;
    }

    Передача структуры в функцию:

    Передача по значению:

    void printPoint(struct Point p) {
        printf("%d %d\n", p.x, p.y);
    }

    Недостаток: копируется вся структура.

    Передача по указателю:

    void movePoint(struct Point *p) {
        p->x += 1;
        p->y += 1;
    }

    Преимущество:

    нет копирования,

    можно изменять исходную структуру.

    Часто структуры используют вместе с typedef.

    typedef struct {
    int x;
        int y;
    } Point;

    Point p = {3, 4};

    Размещение структуры в памяти

    Поля структуры располагаются в памяти последовательно,

    Возможны выравнивания (padding),

    Размер структуры >= сумме размеров полей.

    sizeof(struct Point)
    */

    /*
    19 вопрос.

    Объединение

    Объединение - это пользовательский тип данных языка C, который позволяет хранить разные типы данных в одной и той же области памяти, но только одно значение одновременно.

    Поле объединения

    Поле объединения - отдельный элемент объединения, имеющий имя и тип данных.

    Назначение объединений

    экономия памяти,

    работа с данными, которые могут иметь разный тип в разное время,

    низкоуровневое программирование.

    union Data {
        int i;
        float f;
        char c;
    };

    union Data d;

    d.i = 10;        // записали int
    d.f = 3.14f;     // теперь значение i потеряно

    Все поля используют одну и ту же область памяти.

    Размер объединения:

    sizeof(union Data)

    Равен размеру наибольшего поля.

    Перечисление - это пользовательский тип данных, представляющий собой набор именованных целочисленных констант.

    Перечислитель

    Перечислитель - элемент перечисления, имеющий имя и целочисленное значение.

    Назначение перечислений

    улучшение читаемости кода,

    ограничение множества допустимых значений,

    замена «магических чисел».

    enum Color {
        RED,
        GREEN,
        BLUE
    };

    RED = 0, GREEN = 1, BLUE = 2

    Явное задание значений

    enum ErrorCode {
        OK = 0,
        NOT_FOUND = 404,
        ACCESS_DENIED = 403
    };

    Использование перечислений:

    enum Color c = GREEN;

    if (c == GREEN) {
        printf("Green color\n");
    }

    Класс памяти - это характеристика переменной или функции, определяющая:

    область видимости,

    время жизни,

    способ хранения в памяти,

    доступность из других файлов.


    auto - класс памяти по умолчанию для локальных переменных функции.

    Особенности

    область видимости — блок,

    время жизни — время выполнения блока,

    хранится в стеке.

    void f(void) {
        auto int x = 10; // auto можно не писать
    }

    extern - класс памяти, используемый для объявления переменной или функции, определённой в другом исходном файле.

    file1.c

    int global = 10;

    file2.c

    extern int global;

    void f(void) {
        printf("%d\n", global);
    }

    Особенности

    не выделяет память,

    сообщает компилятору о существовании объекта.

    static - класс памяти, изменяющий время жизни или область видимости переменной.

    static для локальных переменных

    void counter(void) {
        static int cnt = 0;
        cnt++;
        printf("%d\n", cnt);
    }

    сохраняет значение между вызовами,

    время жизни - вся программа.

    static для глобальных переменных

    static int x = 5;

    область видимости ограничена текущим файлом.

    register - класс памяти, рекомендующий компилятору хранить переменную в регистре процессора для ускорения доступа.

    void f(void) {
        register int i;
        for (i = 0; i < 1000; i++) {
            // быстрый счётчик
        }
    }

    Особенности

    компилятор может проигнорировать рекомендацию,

    нельзя брать адрес register-переменной.

    | Класс          | Область видимости | Время жизни   | Назначение                |
    | -------------- | ----------------- | ------------- | ------------------------- |
    | auto           | блок              | блок          | локальные переменные      |
    | extern         | файл/программа    | вся программа | доступ к внешним объектам |
    | static (лок.)  | блок              | вся программа | сохранение значения       |
    | static (глоб.) | файл              | вся программа | скрытие от других файлов  |
    | register       | блок              | блок          | ускорение доступа         |
    */

    /*
    20 вопрос.

    Рекурсия - это способ организации алгоритма, при котором функция вызывает саму себя для решения подзадачи меньшего размера.

    Рекурсивная функция - функция, содержащая вызов самой себя непосредственно или косвенно.

    Базовый случай - условие завершения рекурсии, при котором дальнейшие рекурсивные вызовы не выполняются.

    Рекурсивный шаг - часть алгоритма, в которой функция вызывает саму себя с изменёнными параметрами.

    Стек вызова функций

    Стек вызова функций - область памяти, используемая для хранения информации о вызванных функциях:

    параметров,

    локальных переменных,

    адреса возврата.

    Стек работает по принципу LIFO (последний вошёл - первый вышел).

    Временная сложность - мера количества элементарных операций, выполняемых алгоритмом в зависимости от размера входных данных.

    Пространственная сложность - объём дополнительной памяти, необходимой алгоритму для работы.

    Каждый рекурсивный вызов:

    создаёт новый кадр стека,

    увеличивает глубину стека,

    сохраняет текущее состояние функции.

    При завершении базового случая кадры стека последовательно удаляются.

    Факториал (рекурсия)

    int fact(int n) {
        if (n <= 1)          // базовый случай
            return 1;
        return n * fact(n - 1);  // рекурсивный шаг
    }

    fact(3)
        └─ fact(2)
            └─ fact(1)
    После достижения базового случая значения возвращаются обратно.

    Факториал (итерация)

    int fact(int n) {
        int res = 1;
        for (int i = 2; i <= n; i++)
            res *= i;
        return res;
    }

    Временная сложность рекурсивных и итеративных алгоритмов
    Факториал

    рекурсивный вариант: O(n)

    итеративный вариант: O(n)

    Пример неэффективной рекурсии - числа Фибоначчи

    int fib(int n) {
        if (n <= 1)
            return n;
        return fib(n - 1) + fib(n - 2);
    }
    Временная сложность:

    O(2ⁿ) - из-за повторных вычислений.

    Итеративный вариант Фибоначчи

    int fib(int n) {
        int a = 0, b = 1;
        for (int i = 2; i <= n; i++) {
            int c = a + b;
            a = b;
            b = c;
        }
        return b;
    }

    Временная сложность:

    O(n)

    Пространственная сложность
    Рекурсивные алгоритмы

    требуют дополнительную память для стека,

    пространственная сложность: O(глубины рекурсии).

    Для факториала:

    O(n).

    Итеративные алгоритмы

    используют фиксированное число переменных,

    пространственная сложность обычно O(1).

    | Критерий                   | Рекурсивный | Итеративный |
    | -------------------------- | ----------- | ----------- |
    | Читаемость                 | Высокая     | Средняя     |
    | Временная сложность        | Часто выше  | Обычно ниже |
    | Пространственная сложность | O(n)        | O(1)        |
    | Риск переполнения стека    | Есть        | Нет         |
    | Использование памяти       | Больше      | Меньше      |

    Хвостовая рекурсия - форма рекурсии, при которой рекурсивный вызов является последней операцией функции.

    int fact_tail(int n, int acc) {
        if (n <= 1)
            return acc;
        return fact_tail(n - 1, acc * n);
    }
    */

    /*
    21 вопрос.

    Связный список - это динамическая структура данных, состоящая из элементов (узлов), каждый из которых хранит данные и ссылку на следующий элемент.

    Односвязный список - это связный список, в котором каждый элемент содержит:

    данные,

    указатель только на следующий элемент списка.

    Движение по списку возможно только в одном направлении.

    Узел списка - структура данных, содержащая:

    информационное поле (данные),

    указатель на следующий узел.

    Голова списка - указатель на первый элемент списка.

    Конец списка - элемент, у которого указатель на следующий элемент равен NULL.

    Виды односвязных списков
    1. Линейный (обычный) односвязный список

    последний элемент указывает на NULL,

    самый распространённый вариант.

    head -> [data|*] -> [data|*] -> [data|NULL]

    Кольцевой односвязный список

    последний элемент указывает на первый,

    нет NULL-указателя.

    head -> [ ] -> [ ] -> [ ]
           ↑__________|
    
    Односвязный список с фиктивной головой

    первый элемент не содержит полезных данных,

    упрощает вставку и удаление.

    Объявление узла односвязного списка

    Структура узла списка - пользовательский тип данных, описывающий элемент списка.
    struct Node {
        int data;              // данные
        struct Node *next;     // указатель на следующий узел
    };

    Создание односвязного списка
    Создание одного узла

    struct Node *node = malloc(sizeof(struct Node));
    node->data = 10;
    node->next = NULL;

    Создание списка из нескольких элементов

    #include <stdio.h>
    #include <stdlib.h>

    struct Node {
        int data;
        struct Node *next;
    };

    struct Node* createList(int n) {
        struct Node *head = NULL, *tail = NULL;

        for (int i = 1; i <= n; i++) {
            struct Node *node = malloc(sizeof(struct Node));
            node->data = i;
            node->next = NULL;

            if (head == NULL) {
                head = node;
                tail = node;
            } else {
                tail->next = node;
                tail = node;
            }
        }
        return head;
    }

    Обход списка - последовательный переход по узлам списка от головы к концу.

    void printList(struct Node *head) {
        struct Node *cur = head;
        while (cur != NULL) {
            printf("%d ", cur->data);
            cur = cur->next;
        }
        printf("\n");
    }

    Удаление списка - освобождение всей динамически выделенной памяти, занимаемой узлами списка.

    void freeList(struct Node *head) {
        struct Node *cur = head;
        while (cur != NULL) {
            struct Node *tmp = cur;
            cur = cur->next;
            free(tmp);
        }
    }

    Полный пример программы

    #include <stdio.h>
    #include <stdlib.h>

    struct Node {
        int data;
        struct Node *next;
    };

    struct Node* createList(int n) {
        struct Node *head = NULL, *tail = NULL;
        for (int i = 1; i <= n; i++) {
            struct Node *node = malloc(sizeof(struct Node));
            node->data = i;
            node->next = NULL;

            if (!head) head = tail = node;
            else {
                tail->next = node;
                tail = node;
            }
        }
        return head;
    }

    void printList(struct Node *head) {
        while (head) {
            printf("%d ", head->data);
            head = head->next;
        }
        printf("\n");
    }

    void freeList(struct Node *head) {
        while (head) {
            struct Node *tmp = head;
            head = head->next;
            free(tmp);
        }
    }

    int main(void) {
        struct Node *list = createList(5);
        printList(list);
        freeList(list);
        return 0;
    }

    Преимущества и недостатки односвязных списков
    Преимущества

    динамический размер,

    быстрая вставка и удаление элементов,

    не требует непрерывной памяти.

    Недостатки

    нет прямого доступа по индексу,

    нельзя двигаться назад,

    дополнительная память на указатели.
    */

    /*
    22 вопрос.

    Добавление в начало списка - операция, при которой новый элемент становится первым элементом списка.

    Алгоритм

    Выделить память под новый узел.

    Записать данные.

    Указать next на текущую голову списка.

    Обновить указатель head.

    void pushFront(struct Node **head, int value) {
        struct Node *node = malloc(sizeof(struct Node));
        node->data = value;
        node->next = *head;
        *head = node;
    }
    pushFront(&head, 10);
    pushFront(&head, 20);

    Добавление в конец списка — операция, при которой новый элемент становится последним.

    Алгоритм

    Создать новый узел с next = NULL.

    Найти текущий хвост списка.

    Присвоить tail->next = новый узел.

    void pushBack(struct Node **head, int value) {
        struct Node *node = malloc(sizeof(struct Node));
        node->data = value;
        node->next = NULL;

        if (*head == NULL) {
            *head = node;
            return;
        }

        struct Node *cur = *head;
        while (cur->next != NULL)
            cur = cur->next;

        cur->next = node;
    }

    Удаление из начала списка — операция, при которой удаляется первый элемент списка.

    Алгоритм

    Проверить, что список не пуст.

    Сохранить указатель на текущую голову.

    Сместить head на следующий элемент.

    Освободить память удаляемого узла.

    void popFront(struct Node **head) {
        if (*head == NULL)
            return;

        struct Node *tmp = *head;
        *head = (*head)->next;
        free(tmp);
    }

    Удаление из конца списка — операция, при которой удаляется последний элемент списка.

    Алгоритм

    Проверить, что список не пуст.

    Если элемент один — удалить его и обнулить head.

    Найти предпоследний элемент.

    Освободить последний элемент и установить next = NULL.

    void popBack(struct Node **head) {
        if (*head == NULL)
            return;

        if ((*head)->next == NULL) {
            free(*head);
            *head = NULL;
            return;
        }

        struct Node *cur = *head;
        while (cur->next->next != NULL)
            cur = cur->next;

        free(cur->next);
        cur->next = NULL;
    }

    Пример использования всех операций:

    #include <stdio.h>
    #include <stdlib.h>

    struct Node {
        int data;
        struct Node *next;
    };

    int main(void) {
        struct Node *head = NULL;

        pushFront(&head, 2);
        pushFront(&head, 1);
        pushBack(&head, 3);
        pushBack(&head, 4);

        popFront(&head);
        popBack(&head);

        struct Node *cur = head;
        while (cur) {
            printf("%d ", cur->data);
            cur = cur->next;
        }

        return 0;
    }
    | Операция            | Временная сложность |
    | ------------------- | ------------------- |
    | Добавление в начало | O(1)                |
    | Удаление из начала  | O(1)                |
    | Добавление в конец  | O(n)                |
    | Удаление из конца   | O(n)                |
    */

    /*
    23 вопрос.

    Позиция в списке - порядковый номер элемента списка, отсчитываемый от начала списка.
    Как правило:

    первая позиция имеет номер 0 или 1 (зависит от соглашения).

    В данном примере используется нумерация с нуля.

    Вставка элемента в произвольную позицию - операция, при которой новый узел помещается в список так, что он занимает заданную позицию, а остальные элементы смещаются.

    Случаи вставки

    Вставка в начало списка (позиция 0).

    Вставка в середину списка.

    Вставка в конец списка (позиция равна длине списка).

    Общий алгоритм

    Выделить память под новый узел.

    Записать данные.

    Найти элемент, предшествующий заданной позиции.

    Изменить указатели так, чтобы новый элемент оказался в нужном месте.

    Обновить head при необходимости.

    struct Node {
        int data;
        struct Node *next;
    };

    #include <stdlib.h>

void insertAt(struct Node **head, int value, int pos) {
    if (pos < 0) return;

    struct Node *node = malloc(sizeof(struct Node));
    node->data = value;

        // Вставка в начало 
        if (pos == 0) {
            node->next = *head;
            *head = node;
            return;
        }

        struct Node *cur = *head;
        for (int i = 0; i < pos - 1 && cur != NULL; i++) {
            cur = cur->next;
        }

        if (cur == NULL) {
            // позиция больше длины списка //
            free(node);
            return;
        }

        node->next = cur->next;
        cur->next = node;
    }

    Пример использования:

    #include <stdio.h>
    #include <stdlib.h>

    struct Node {
        int data;
        struct Node *next;
    };

    void printList(struct Node *head) {
        while (head) {
            printf("%d ", head->data);
            head = head->next;
        }
        printf("\n");
    }

    int main(void) {
        struct Node *head = NULL;

        insertAt(&head, 1, 0); // [1]
        insertAt(&head, 3, 1); // [1, 3]
        insertAt(&head, 2, 1); // [1, 2, 3]
        insertAt(&head, 0, 0); // [0, 1, 2, 3]

        printList(head);
        return 0;
    }
    | Операция           | Сложность |
    | ------------------ | --------- |
    | Вставка в начало   | O(1)      |
    | Вставка в середину | O(n)      |
    | Вставка в конец    | O(n)      |
    */

    /*
    24 вопрос.

    Удаление элемента - операция, при которой узел исключается из списка, а занимаемая им память освобождается.

    Удаление элемента с произвольной позиции используется, когда необходимо:

    удалить элемент по индексу,

    динамически изменять структуру списка,

    освобождать память, занятую ненужными данными.

    Основные случаи

    Удаление из начала списка (позиция 0).

    Удаление из середины списка.

    Удаление из конца списка.

    Общий алгоритм

    Проверить, что список не пуст.

    Если позиция равна 0:

    сместить head на следующий элемент,

    освободить память удаляемого узла.

    Иначе:

    найти элемент, предшествующий удаляемому,

    изменить его указатель next,

    освободить память удаляемого узла.

    Обработать случай некорректной позиции.

    #include <stdlib.h>

    void removeAt(struct Node **head, int pos) {
        if (*head == NULL || pos < 0)
            return;

        //Удаление первого элемента
        if (pos == 0) {
            struct Node *tmp = *head;
            *head = (*head)->next;
            free(tmp);
            return;
        }

        struct Node *cur = *head;
        for (int i = 0; i < pos - 1 && cur->next != NULL; i++) {
            cur = cur->next;
        }

        // Проверка корректности позиции 
        if (cur->next == NULL)
            return;

        struct Node *toDelete = cur->next;
        cur->next = toDelete->next;
        free(toDelete);
    }

    #include <stdio.h>
    #include <stdlib.h>

    struct Node {
        int data;
        struct Node *next;
    };

    void printList(struct Node *head) {
        while (head) {
            printf("%d ", head->data);
            head = head->next;
        }
        printf("\n");
    }

    int main(void) {
        struct Node *head = NULL;

        // Формируем список: 1 → 2 → 3 → 4
        removeAt(&head, 0); // безопасно: список пуст

        // Ручное создание
        head = malloc(sizeof(struct Node));
        head->data = 1;
        head->next = malloc(sizeof(struct Node));
        head->next->data = 2;
        head->next->next = malloc(sizeof(struct Node));
        head->next->next->data = 3;
        head->next->next->next = malloc(sizeof(struct Node));
        head->next->next->next->data = 4;
        head->next->next->next->next = NULL;

        removeAt(&head, 2); // удаляем элемент с позицией 2 (значение 3)
        printList(head);    // 1 2 4

        removeAt(&head, 0); // удаляем первый элемент
        printList(head);    // 2 4

        return 0;
    }

    | Операция             | Временная сложность |
    | -------------------- | ------------------- |
    | Удаление из начала   | O(1)                |
    | Удаление из середины | O(n)                |
    | Удаление из конца    | O(n)                |

    */
}