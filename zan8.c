#include <stdio.h>
#include <stdarg.h>
#include "8_dop.c"
#define M 23
#define BEGIN {
#define END }
#define ADD(a,b) (a+b)
#define STRING "Hello \n"
#define HELLO printf("Hello, dear world \n")
#define FOR for(int i = 0; i < 4; i++)
#define print(a) printf("%d \n", a)
#define min(a,b) (a < b ? a : b)
#define square(n) (n)*(n)
#define print1(a,b,c) printf("%d \n", a##b##c)
#define PERSON struct {int age; char name[20];}

int sum(int n, ...)
{
    int result = 0;
    va_list factor; //указатель на va_list
    va_start(factor, n); //связь указателя с первым необязательным параметром
    for (int i = 0; i < n; i++)
    {
        result += va_arg(factor, int); //получаю значение текущего параметра
    }
    va_end(factor); //заверашем работу параметров
    return result;
}

int mult(int a, int b)
BEGIN
    return a * b;
END

struct person;
struct person_full; //структура объявлена, но не определена, она пока представляет неполный тип
//структура определена, мы можем ее полноценно использовать
struct person_full
{
    char* name;
    int age;
};
struct person_full;
struct person_full;
struct person_full;

struct person_fullll;

//одновременное совмещение определение типа структуры и переменных
struct person_F
{
    int age;
    char* name;
} Ivan; //определение структуры и ее переменной

struct person_f
{
    int age;
    char* name;
} ivan = {24, "Ivan"};

struct person_fff
{
    int age;
    char* name;
} peter, bob, alice;

struct
{
    int age;
    char* name;
} Ilya;

//В отличе от всех проимеров при определении объекта структура не надо использовать struct
typedef struct
{
    int age;
    char* name;
} personnn;

void print_person()
{
    struct person_full bob = {"Bob", 33};
    printf("Age = %d, name = %s \n", bob.age, bob.name);

    struct hello;
    struct hello
    {
        char* hello;
    } hi;
}

int main(void){
    /*
    для определения параметров неопределенной длины в таких функциях используется многоточие
    тип имя_функции(обязательные параметры, ...). при это стоит учитывать, что функция должна иметь хотя бы 1 обязательный параметр
    stdarg.h

    va_start()
    va_arg()
    va_end()
    va_list() - тип данных каждого макроса сверху, который также определен в stdarh.h и который позволяет обрабатывать нефиксированный набор параметров

    Макрос va_start имеет следующее определение:
    void va_start(va_list param, последний_явный_параметр)
    Первый параметр макроса - param связывает объект va_list с первым необязательным параметром. Для его определения в качестве второго параметра 
    в макрос передается последний обязательный параметр функции. таким образом, используя последния обязательный параметр, мы можем нацелить объект
    va_list на адрес первого необязательного параметры. Фактически va_list выступает в роли уазателя.

    type va_arg(va_list param, type)
    Этот макрос позволяет получить значение параметра типа type, а также переместить указатель va_list на следующий необязательный параметр

    va_end()
    void va_end(va_list param)
    Макрос va_end() позволяет выйти из функции с переменным списком параметромв. 
    */
    printf("%d \n", sum(4, 1, 2, 3, 4));
    printf("%d \n", sum(8, 1, 2, 3, 4, 5, 6, 7, 8));
    /*
    Процесс компиляции на Си разбивается на три этапа
    1. Препоцессор
    2. Компиляция
    3. Линковка

    Препроцессор обрабатывает исходный текст программы до ее компиляции. Результатом работы препроцессора является полный текст программы, который
    передается на компиляцию в исполняемый файл

    Затем компилятор компилирует обработанный препроцессорым исходный код в объектные файлы

    На последнем этапе линкер (линковщик) объединеят (линкует) объектные файлы в оидн исполняемы файл или файл динамическое библиотеки

    Для управления препроцессором применяются директивы, каждая из который начинается с # и располагается на отдельной строке. Препроцессор
    просматривает текст программы, находит директивы и должным образом их обрабатывает.


    #define: определяет макрос или препроцессорный идентификатор
    #undef: отменяет определение макроса или идендификатора
    #ifdef: проверяет, определен ли идентификатор
    #ifndef: проверяет, неопределен ли идентификатор
    #include: включает текст из файла
    #if: проверяет условие выражения
    #else: задает альтернативное условие для #if
    #endif: окончание условной директивы #if
    #elif: задает альтернативное условие для #if
    #line: меняет номер следующей ниже строки
    #error: формирует текст сообщения об ошибке
    #pragma: определяет действия, которые зависят от конкретной реализации компилятора
    #: пустая директива, которая по сути ничего не делает

    #include <stdio.h>
    #include "stdio.h"
    */
   printf("%d \n", sub(1, 3));

    /*
    Директива #define определяет идентификатор и последжовательность символов, которые будут подставляться вместо идентификатор каждый раз, когда он
    встретится в исходном файле.
    #define идентификатор последовательность_символов.
    Все идентификаторы, которые определяются при помощи define называются макросами.

    #define HELLO printf("Hello, dear world \n")
    #define FOR for(int i = 0; i < 4; i++)
    Подобный определения define имеют один недостаток. Последовательность символов, которая используется директивой фиксирована.

    Если надо передавать строку динамчески, то есть строка может быть любой.
    #define имя_макроса(список_параметров) последовательность символов. Список параметров - список различных идентификаторов, разделенных запятыми.
    Между именем макроса и открывающей скобкой не должно быть пробелов. Для обращения к макросу будет использована следующая конструкция:
    имя_макроса(список_аргументов). Список аргументов - набор значений, которые передаются для кажддого параметра макроса.
    При определении макроса его параметры следует заключать в скобки.
    При обработке исходного кода препроцессор может выполнять две препроцессорные операции: #, ##.
    # - операция, которая позволяет заключать текст параметра, которые следует после операции, в кавычки
    ## позволябт объединить две лексемы
    */
    /*
    Директива #undef отменяет действие макроса. Имеет следующее определение
    #undef идентификатор
    */
    printf("%d \n", M);
    printf("%d \n", mult(1, 3));
    printf("%d \n", ADD(1,3));
    printf(STRING);
    #undef STRING
    #define STRING "Hello, world \n"
    printf(STRING);
    FOR HELLO;
    print(M);
    print(sub(1, 3));
    print(min(1, 3));
    int x = square(2+3); //2+3*2+3 (без скобок), поэтому параметры заключаем в скобки
    print1(123, 456, 789);
    print(x);

    /*
    Директивы условной компиляции позволяют в зависимости от условий добавить в файл определенный код.
    #if, #else, #endif

    #if условие
    исходный_код
    #endif
    */
   #if M == 23
    printf("M=23 \n");
   #else
    printf("M неопределено \n");
   #endif
   /*
   #ifdef проверяет, определен ли идентификатор, и если он определен, то будет вставляться в исходной код какой-то текст
   */
   #ifdef M
    printf("M=23 \n");
   #endif

   /*
   #ifndef проверяет не определен ли идентификатор, и если он не определен, то будет вставляться в исходный код какой-то текст
   */
   #ifndef DEBUG
    printf("Такого идентификатора нет \n");
   #endif

   /*
   Если надо проверить одновременно значения двух идентификатор, то можно использовать специальный оператор defined
   */

   #if defined BEGIN && defined END
    printf("Есть и BEGIN и END \n");
   #elif defined BEGIN && !defined END
    printf("Есть BEGIN, но нет END \n");
   #elif !defined BEGIN && defined END
    printf("Есть END, но нет BEGIN \n");
   #else
    printf("Нет ничего \n");
   #endif

   /*
   Различные архитектуры, ОС и компиляторы могут определять некоторые макросы, которые можно использовать.
   */

   #ifdef _WIN16
    printf("16 bit \n");
   #elif _WIN64
    printf("64 bit \n");
   #endif

   /*
   Структура в Си предствляют составной тип данных, который состоит из других компонентов. При этом в отличе от массива эти компоненты могут представлять
   различные типы данных.

   Объявление и определение структуры:
   Для определения структуры применяется ключевое слово struct. Есть два типа объявления структуры. В первом случае после ключевого слова struct идет
   имя структуры.

   struct имя_структуры;

   Имя структуры представляет произвольный идентификатор, к которому применяются те же правила, что и при наименовании переменных. С такими структурами
   работать сложно, так как она представляет неполный тип, поскольку мы не знаем, какой размер занимает эта структура.

   Второ тип объявления - с объявлением.

   struct имя_структуры
   {
    компоненты_структуры
   }

   После определения структуры мы можем ее использовать. Для начала мы можем определить объект структуры - по сути обычная переменная, которая будет
   представлять выше созданный тип.
   */
  
  //При каждом определении переменной типа структур ей будет выделяться память, необходимая для хранения ее элементов
  //Есть два способа инициализации структуры

  //По позиции (значения преедются элементам структуры в том порядке, в котором они следуют в структуре)
    struct person_full Andrew = {"Andrew", 18};
    //По имени (значения передаются элементам структуры по имени, независимо от порядка)
    struct person_full Gennady = {.age = 22, .name = "Gennady"};
    //Перед именем порядка идет точка

    //Для обращения к элементам структуры используется операция точка
    //имя_переменной_структуры.имя_поля
    printf("Age = %d, name = %s \n", Andrew.age, Andrew.name);
    //Стоит отметить, что можно использовать структуру полноценно (обращаться к ее полям) в основном после ее определения

    /*Если структура определена после функции main и до своего определения она представляет неполный тип - компилятор не знает его размера, наккаие поля
    в нем соответственно полноценно использовать нельзя. Единственный выходом из ситуации использования неполного типа является определения
    указателя тип
    */
   struct person_fullll *Tom;
   Ivan.age = 38;
   Ivan.name = "Ivan";
   printf("Age = %d, name = %s \n", Ivan.age, Ivan.name);

   personnn Olga = {23, "Olga"};
   PERSON Vladimir = {50, "Vladimir"};
   printf("Age = %d, name = %s \n", Vladimir.age, Vladimir.name);


   /*
   Область действия структур:

   Как и функции, и переменные, структуры имеют область видимости и видны только в той области, в которой объявлены. Если структура определена вне
   функций на уровне файла, то она видна глобально.
   */
  /*
  Копирование структур. Одну структуру можно присваивать другой структуре того же типа. При копировании элементы структуры получают
  копии значений
  */
   struct person_full Lida = Andrew;
   Lida.name = "Lida";
   printf("Age = %d, name = %s \n", Lida.age, Lida.name);

   struct person_full Marya = {"Marya", 20};
   printf("Enter name: ");
   scanf("%d", &Marya.age);
   printf("Age = %d, name = %s \n", Marya.age, Marya.name);
   return 0;
}

struct person_fullll
{
    char* name;
    int age;
};
/*
int main(int argc, char *argv[]){ 
    //argc - представляет количество аргументов командной строки, который переданы приложению
    //argv - представляет указатель на массив строк, который представляет переданный набор аргументов
    for (int i = 0; i < argc; i++){
        printf("%s \n", argv[i]);
    }
    return 0;
}
*/
